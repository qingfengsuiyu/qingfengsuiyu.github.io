<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>八股积累-02 | DayBreak</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1、HTTP缓存 HTTP缓存是一种优化技术，浏览器或中间缓存服务器（如CDN）将请求过的Web资源（如HTML页面、图片、CSS、JS文件）存储起来。当用户再次请求相同资源时，可以直接从本地缓存或邻近的缓存服务器中获取，而无需向源服务器发送请求。这大大减少了请求延迟，节省了网络带宽，降低了服务器负载，提升了用户体验。 HTTP缓存主要分为两大类：  强制缓存 (Strong Cache): 浏览">
<meta property="og:type" content="article">
<meta property="og:title" content="八股积累-02">
<meta property="og:url" content="http://example.com/2025/04/15/%E5%85%AB%E8%82%A1%E7%A7%AF%E7%B4%AF-02/index.html">
<meta property="og:site_name" content="DayBreak">
<meta property="og:description" content="1、HTTP缓存 HTTP缓存是一种优化技术，浏览器或中间缓存服务器（如CDN）将请求过的Web资源（如HTML页面、图片、CSS、JS文件）存储起来。当用户再次请求相同资源时，可以直接从本地缓存或邻近的缓存服务器中获取，而无需向源服务器发送请求。这大大减少了请求延迟，节省了网络带宽，降低了服务器负载，提升了用户体验。 HTTP缓存主要分为两大类：  强制缓存 (Strong Cache): 浏览">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-04-15T08:36:47.000Z">
<meta property="article:modified_time" content="2025-04-15T08:37:17.812Z">
<meta property="article:author" content="Xiaoyi Hao">
<meta property="article:tag" content="八股文">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="DayBreak" type="application/atom+xml">
  
  
  
  
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0.css">

  
<link rel="stylesheet" href="/lib/fancybox/dist/jquery.fancybox.min.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<script src="/lib/jquery/dist/jquery.min.js"></script>

  
  
  
  
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="wrapper">
    <header id="header" class="clearfix">
	<a id="logo" href="/" title="DayBreak">DayBreak</a>
	
	<nav id="nav-menu" class="clearfix">
		<form id="search" method="post" action="./" role="search">
			<input id="search-input" type="text" name="s" class="inputbox" value="Search" onfocus="if (value =='Search'){value =''}" onblur="if (value ==''){value='Search'}">
		</form>
		<ul>
      
				
        <li><a class="main-nav-link" href="/">Home</a></li>
      
				
        <li><a class="main-nav-link" href="/archives">Archives</a></li>
      
		</ul>
	</nav>
</header>
    <section id="main" class="clearfix"><article class="post-detail">
  <h1 class="post-title"><a href="/">八股积累-02</a></h1>
  <ul class="post-meta">
  <li><i class="fa fa-user"></i> Author Xiaoyi Hao</li>
  <li><i class="fa fa-calendar"></i> Date Apr 15</li>
  <li><i class="fa fa-folder"></i> Categories
  
    no_categories
  
  </li>
</ul>
  <div class="post-content">
      
      <p><strong>1、HTTP缓存</strong></p>
<p>HTTP缓存是一种优化技术，浏览器或中间缓存服务器（如CDN）将请求过的Web资源（如HTML页面、图片、CSS、JS文件）存储起来。当用户再次请求相同资源时，可以直接从本地缓存或邻近的缓存服务器中获取，而无需向源服务器发送请求。这大大减少了请求延迟，节省了网络带宽，降低了服务器负载，提升了用户体验。</p>
<p>HTTP缓存主要分为两大类：</p>
<ul>
<li><strong>强制缓存 (Strong Cache):</strong><ul>
<li>浏览器直接检查本地缓存的有效性，无需向服务器发送请求。</li>
</ul>
</li>
<li><strong>协商缓存 (Negotiation Cache &#x2F; Conditional Cache):</strong><ul>
<li>强制缓存失效后（或者<code>Cache-Control: no-cache</code>），浏览器会向服务器发送一个条件请求。</li>
<li>服务器根据请求中的条件判断资源是否有更新。</li>
<li>如果服务器判断资源未改变，返回 <code>304 Not Modified</code>，浏览器便可安全地使用本地缓存。</li>
</ul>
</li>
</ul>
<p><strong>缓存流程:</strong> 浏览器请求资源 -&gt; 检查强制缓存 (Cache-Control&#x2F;Expires) -&gt; 若命中且有效，直接使用 (200 from cache) -&gt; 若强制缓存无效或不存在 -&gt; 发起HTTP请求，带上协商缓存头 (If-Modified-Since&#x2F;If-None-Match) -&gt; 服务器检查协商缓存头 -&gt; 若资源未改变，返回304，浏览器使用本地缓存 -&gt; 若资源已改变，返回200和新资源，浏览器更新缓存。</p>
<p><strong>2、跨域</strong></p>
<p>跨域是指浏览器出于安全原因，限制网页脚本访问不同源 (Origin) 的资源。<strong>源</strong>由<strong>协议 (Protocol)</strong>、<strong>域名 (Domain&#x2F;Host)</strong> 和 <strong>端口 (Port)</strong> 三者共同定义。只要这三者中有一个不同，就构成跨域。</p>
<p>这是浏览器的<strong>同源策略 (Same-Origin Policy, SOP)</strong> 导致的，它是一个重要的安全基石，旨在防止恶意网站读取或篡改其他网站的敏感数据。</p>
<p>常见的跨域场景包括：</p>
<ul>
<li>AJAX 请求访问不同源的 API。</li>
<li>页面中的 <code>&lt;iframe&gt;</code> 加载不同源的页面，并试图通过脚本进行交互。</li>
<li>Web 字体、Canvas&#x2F;WebGL 绘制使用了不同源的图片等。</li>
</ul>
<p><strong>3、前端缓存有哪几种</strong></p>
<p>前端缓存是指将数据或资源存储在客户端（浏览器）的技术，以提高应用性能和用户体验。主要有以下几种：</p>
<ol>
<li><strong>HTTP 缓存:</strong> (前面已详细说明) 浏览器根据 HTTP 响应头自动处理的资源缓存（强缓存、协商缓存）。这是最基础也是应用最广泛的缓存。</li>
<li><strong>LocalStorage:</strong> HTML5 Web Storage API 提供的<strong>持久化本地存储方案</strong>。以<strong>键值对（Key-Value）形式</strong>存储<strong>字符串</strong>数据。<strong>除非用户手动清除浏览器数据或代码主动删除，否则数据会一直存在</strong>，即使关闭浏览器或标签页也不会消失。容量通常为 5-10MB。<strong>同源限制</strong>。</li>
<li><strong>SessionStorage:</strong> 与 LocalStorage 类似，也是键值对存储字符串。但它的生命周期与<strong>浏览器会话</strong>绑定，即<strong>当标签页或浏览器窗口关闭后，SessionStorage 中存储的数据会被清除</strong>。容量和同源限制同 LocalStorage。适合存储临时性的会话数据。</li>
<li><strong>IndexedDB:</strong> 一个在浏览器中运行的、功能强大的<strong>事务型</strong>数据库系统。允许存储大量的结构化数据（包括文件&#x2F;Blob），并支持索引以实现高性能查询。API 是<strong>异步</strong>的。比 LocalStorage&#x2F;SessionStorage 复杂，但提供了更强大的数据管理能力。同源限制。</li>
<li><strong>Cookies:</strong> 小段文本信息，由服务器通过 <code>Set-Cookie</code> 响应头发送给浏览器，浏览器将其存储，并在后续对<strong>同一服务器</strong>的<strong>每次</strong>请求中通过 <code>Cookie</code> 请求头自动带上。**主要用于用户身份认证、会话管理、跟踪用户行为等。缺点是容量小（约 4KB），且每次请求都会携带，可能造成带宽浪费。**可以通过设置 <code>HttpOnly</code> 防止脚本访问，提高安全性。</li>
</ol>
<p><strong>4、防抖和节流如何实现</strong></p>
<p>防抖 (Debounce) 和节流 (Throttle) 是两种优化高频触发事件（如 <code>resize</code>, <code>scroll</code>, <code>input</code> 等）的常用技术，它们都通过<strong>返回一个新函数</strong>来实现。</p>
<ul>
<li><p><strong>防抖 (Debounce) 实现:</strong></p>
<ul>
<li><strong>目标:</strong> 在事件触发后，等待一段指定的延迟时间。如果在这段延迟时间内没有新的事件触发，则执行目标函数；如果延迟时间内又有新的事件触发，则<strong>重新计时</strong>。简而言之：<strong>只在最后一次触发后的指定延迟后执行一次</strong>。</li>
<li><strong>实现思路:</strong> 使用 <code>setTimeout</code> 来管理延迟执行。每次事件触发时，先清除之前的定时器，然后设置一个新的定时器。</li>
</ul>
<p>JavaScript</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; func 要执行的目标函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; delay 延迟时间 (ms)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Function</span>&#125; 包装后的防抖函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeoutId = <span class="literal">null</span>; <span class="comment">// 定时器 ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个新函数，这个函数将作为事件处理程序</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 保存 this 上下文和参数</span></span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已有定时器，则清除它（取消之前的延迟执行）</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置一个新的定时器</span></span><br><span class="line">    timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 延迟时间到了，执行目标函数</span></span><br><span class="line">      <span class="comment">// 使用 apply 来保持正确的 this 指向和传递参数</span></span><br><span class="line">      func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">      timeoutId = <span class="literal">null</span>; <span class="comment">// 执行完毕，重置 timeoutId (可选)</span></span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 使用示例 ---</span></span><br><span class="line"><span class="comment">// const debouncedHandler = debounce(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&#x27;窗口大小已停止变化一段时间&#x27;);</span></span><br><span class="line"><span class="comment">// &#125;, 500);</span></span><br><span class="line"><span class="comment">// window.addEventListener(&#x27;resize&#x27;, debouncedHandler);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>节流 (Throttle) 实现:</strong></p>
<ul>
<li><strong>目标:</strong> 在指定的<strong>时间间隔内，最多只执行一次</strong>目标函数。无论事件触发多频繁，都会以固定的频率执行。简而言之：<strong>固定时间内只执行一次，多余的触发忽略</strong>。</li>
<li><strong>实现思路 (基于定时器):</strong> 使用一个标志位（或检查定时器是否存在）来判断是否可以执行。如果可以执行，则立即执行（或设置定时器执行），然后设置一个定时器，在时间间隔结束后才允许下一次执行。</li>
</ul>
<p>JavaScript</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数 (基于定时器，首次触发可能延迟)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; func 要执行的目标函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; interval 时间间隔 (ms)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Function</span>&#125; 包装后的节流函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeoutId = <span class="literal">null</span>; <span class="comment">// 定时器 ID</span></span><br><span class="line">  <span class="keyword">let</span> lastArgs = <span class="literal">null</span>; <span class="comment">// 保存最后一次的参数</span></span><br><span class="line">  <span class="keyword">let</span> lastThis = <span class="literal">null</span>; <span class="comment">// 保存最后一次的 this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个新函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    lastArgs = args; <span class="comment">// 保存参数</span></span><br><span class="line">    lastThis = <span class="variable language_">this</span>; <span class="comment">// 保存 this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果定时器不存在，表示可以设置新的执行</span></span><br><span class="line">    <span class="keyword">if</span> (!timeoutId) &#123;</span><br><span class="line">      timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 时间间隔到了，执行函数</span></span><br><span class="line">        func.<span class="title function_">apply</span>(lastThis, lastArgs);</span><br><span class="line">        <span class="comment">// 清除定时器，允许下一次设置</span></span><br><span class="line">        timeoutId = <span class="literal">null</span>;</span><br><span class="line">        lastArgs = <span class="literal">null</span>;</span><br><span class="line">        lastThis = <span class="literal">null</span>;</span><br><span class="line">      &#125;, interval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果定时器已存在，则忽略本次触发（或者也可以选择在定时器结束后执行最后一次触发的调用）</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 使用示例 (另一种常见实现：首次立即执行，之后节流) ---</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttleImmediate</span>(<span class="params">func, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span>; <span class="comment">// 标志位，表示是否可以立即执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) &#123;</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 如果不能运行，则忽略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    canRun = <span class="literal">false</span>; <span class="comment">// 标记为不能立即运行</span></span><br><span class="line">    <span class="comment">// 立即执行一次</span></span><br><span class="line">    func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器，在 interval 毫秒后恢复 canRun</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, interval);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// const throttledHandler = throttleImmediate(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&#x27;滚动事件被节流处理&#x27;);</span></span><br><span class="line"><span class="comment">// &#125;, 200);</span></span><br><span class="line"><span class="comment">// window.addEventListener(&#x27;scroll&#x27;, throttledHandler);</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>5、代码题， 大数相加</strong></p>
<p>当两个数字非常大，超过了 JavaScript 的 <code>Number.MAX_SAFE_INTEGER</code> (2^53 - 1)，直接使用 <code>+</code> 运算符会丢失精度。这时需要将数字作为字符串处理，模拟手动加法的过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大数相加</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; num1 第一个大数（字符串形式）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; num2 第二个大数（字符串形式）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">string</span>&#125; 两个大数相加的结果（字符串形式）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addBigIntegers</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = num1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 指向 num1 末尾</span></span><br><span class="line">  <span class="keyword">let</span> j = num2.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 指向 num2 末尾</span></span><br><span class="line">  <span class="keyword">let</span> carry = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 结果字符串</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从个位开始，只要还有数字位或者有进位，就继续循环</span></span><br><span class="line">  <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取当前位的数字，如果索引&lt;0，则视为 0</span></span><br><span class="line">    <span class="keyword">const</span> digit1 = i &gt;= <span class="number">0</span> ? <span class="built_in">parseInt</span>(num1[i]) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> digit2 = j &gt;= <span class="number">0</span> ? <span class="built_in">parseInt</span>(num2[j]) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前位的和（加上进位）</span></span><br><span class="line">    <span class="keyword">const</span> sum = digit1 + digit2 + carry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前位的结果是 sum % 10</span></span><br><span class="line">    <span class="keyword">const</span> currentDigit = sum % <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 新的进位是 Math.floor(sum / 10)</span></span><br><span class="line">    carry = <span class="title class_">Math</span>.<span class="title function_">floor</span>(sum / <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前位的结果拼接到结果字符串的前面</span></span><br><span class="line">    result = currentDigit + result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动索引</span></span><br><span class="line">    i--;</span><br><span class="line">    j--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果结果是 &#x27;0&#x27;，并且输入不是 &#x27;0&#x27; + &#x27;0&#x27;，确保返回 &#x27;0&#x27; 而不是空串（虽然此逻辑下不会是空串）</span></span><br><span class="line">  <span class="comment">// 此处可以简化，因为循环条件保证了至少处理一次</span></span><br><span class="line">  <span class="comment">// if (result === &#x27;&#x27; &amp;&amp; (num1 !== &#x27;0&#x27; || num2 !== &#x27;0&#x27;)) return &#x27;0&#x27;; // 防御性代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 示例测试 ---</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addBigIntegers</span>(<span class="string">&quot;123&quot;</span>, <span class="string">&quot;456&quot;</span>)); <span class="comment">// 输出: &quot;579&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addBigIntegers</span>(<span class="string">&quot;99&quot;</span>, <span class="string">&quot;1&quot;</span>));    <span class="comment">// 输出: &quot;100&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addBigIntegers</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;999&quot;</span>));   <span class="comment">// 输出: &quot;1000&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addBigIntegers</span>(<span class="string">&quot;12345678901234567890&quot;</span>, <span class="string">&quot;98765432109876543210&quot;</span>)); <span class="comment">// 输出: &quot;111111111001111111100&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addBigIntegers</span>(<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>));     <span class="comment">// 输出: &quot;0&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>实现思路:</strong></p>
<ol>
<li>初始化两个指针 <code>i</code> 和 <code>j</code> 分别指向两个数字字符串的末尾，进位 <code>carry</code> 为 0，结果字符串 <code>result</code> 为空。</li>
<li>使用 <code>while</code> 循环，条件是 <code>i</code> 或 <code>j</code> 没有越界（还没处理完所有位），或者 <code>carry</code> 大于 0（最高位有进位）。</li>
<li>在循环内部：<ul>
<li>获取 <code>num1[i]</code> 和 <code>num2[j]</code> 对应的数字。如果索引已经小于 0，则该位视为 0。使用 <code>parseInt()</code> 转换字符为数字。</li>
<li>计算 <code>sum = digit1 + digit2 + carry</code>。</li>
<li>当前位的值是 <code>sum % 10</code>。</li>
<li>新的进位是 <code>Math.floor(sum / 10)</code>。</li>
<li>将当前位的值（<code>sum % 10</code>）<strong>拼接</strong>到 <code>result</code> 字符串的<strong>前面</strong>。</li>
<li>将 <code>i</code> 和 <code>j</code> 向前移动（<code>i--</code>, <code>j--</code>）。</li>
</ul>
</li>
<li>循环结束后，<code>result</code> 就是最终的、正确顺序的和。</li>
</ol>
<h4 id="缓存策略应用："><a href="#缓存策略应用：" class="headerlink" title="缓存策略应用："></a><strong>缓存策略应用：</strong></h4><ul>
<li><strong>不常变化的静态资源（CSS, JS, 图片, 字体）：</strong> 设置很长的<code>max-age</code>（例如一年 <code>max-age=31536000</code>），并配合<strong>内容哈希或版本号</strong>的文件名（如 <code>style.a1b2c3d4.css</code> 或 <code>main.v1.js</code>）。当文件内容更新时，文件名改变，浏览器会请求新资源；文件名不变时，则长期利用缓存。</li>
<li><strong>可能会变化的资源（HTML，某些API数据）：</strong> 使用 <code>no-cache</code> 或 <code>max-age=0</code>，强制每次使用前进行验证（发送<code>If-Modified-Since</code>或<code>If-None-Match</code>请求）。如果资源未变，服务器返回<code>304</code>，只传输少量头部信息，仍然比重新下载整个资源快。</li>
<li><strong>敏感数据或频繁变化的API数据：</strong> 使用<code>no-store</code>，完全禁止缓存。</li>
</ul>
<h4 id="那么请你详细描述一下-从在浏览器地址栏输入一个URL-到最终页面渲染出来的整个过程"><a href="#那么请你详细描述一下-从在浏览器地址栏输入一个URL-到最终页面渲染出来的整个过程" class="headerlink" title="那么请你详细描述一下,从在浏览器地址栏输入一个URL.到最终页面渲染出来的整个过程."></a>那么请你详细描述一下,从在浏览器地址栏输入一个URL.到最终页面渲染出来的整个过程.</h4><ol>
<li><p><strong>用户输入与URL解析:</strong></p>
<ul>
<li>用户在浏览器地址栏输入URL（例如 <code>https://www.example.com/path?query=value#fragment</code>）。</li>
<li>浏览器首先解析这个URL，识别出协议 (<code>https</code>)、域名 (<code>www.example.com</code>)、端口（HTTPS默认为443）、路径 (<code>/path</code>)、查询参数 (<code>?query=value</code>) 和片段标识符 (<code>#fragment</code>)。</li>
<li>如果输入的是搜索词而非URL，浏览器会使用默认搜索引擎将其转换为搜索结果页面的URL。</li>
</ul>
</li>
<li><p><strong>检查缓存:</strong></p>
<ul>
<li><p>浏览器缓存:</p>
<p>浏览器首先检查其本地缓存（内存缓存、磁盘缓存）。它会根据URL和缓存策略（</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires</span><br></pre></td></tr></table></figure>

<p>）判断是否存在有效（未过期）的资源副本。</p>
<ul>
<li><strong>强缓存命中:</strong> 如果找到未过期的有效副本（在<code>max-age</code>内），浏览器直接从缓存读取资源，不发起网络请求。这是最快的情况（可能看到 <code>200 OK (from memory cache)</code> 或 <code>200 OK (from disk cache)</code>）。整个过程可能在这里就结束了HTML文档的获取。</li>
<li><strong>协商缓存:</strong> 如果资源已过期或被标记为<code>no-cache</code>，浏览器需要向服务器验证资源是否更新。它会准备发起网络请求，并在请求头中带上缓存标识（如<code>If-Modified-Since</code>或<code>If-None-Match</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>DNS域名解析:</strong></p>
<ul>
<li><p>如果缓存未命中或需要验证，浏览器需要知道目标服务器的IP地址。</p>
</li>
<li><p><strong>查找本地缓存:</strong> 浏览器先检查自身DNS缓存 -&gt; 操作系统<code>hosts</code>文件 -&gt; 操作系统DNS缓存。</p>
</li>
<li><p><strong>路由器缓存:</strong> 如果本地没有，查询路由器的DNS缓存。</p>
</li>
<li><p><strong>ISP DNS服务器:</strong> 查询本地ISP（互联网服务提供商）提供的DNS服务器。</p>
</li>
<li><p>根域名服务器查询 (递归过程):</p>
<p>如果ISP DNS服务器也没有缓存，它会发起递归查询：</p>
<ul>
<li>ISP DNS问 <strong>根域名服务器</strong>: “.com” 域名的顶级域（TLD）服务器地址是什么？</li>
<li>根服务器返回 <strong>TLD服务器</strong> 地址。</li>
<li>ISP DNS问 <strong>TLD服务器</strong>: “example.com” 的权威名称服务器（Authoritative Name Server）地址是什么？</li>
<li>TLD服务器返回 <strong>权威名称服务器</strong> 地址。</li>
<li>ISP DNS问 <strong>权威名称服务器</strong>: “<a target="_blank" rel="noopener" href="https://www.example.com/">www.example.com</a>“ 的IP地址是什么？</li>
<li>权威名称服务器返回最终的IP地址。</li>
</ul>
</li>
<li><p><strong>结果缓存:</strong> ISP DNS服务器缓存这个结果（遵循TTL），并返回给操作系统，操作系统再返回给浏览器。</p>
</li>
</ul>
</li>
<li><p><strong>建立TCP连接:</strong></p>
<ul>
<li>浏览器获得IP地址和端口号（HTTP默认80，HTTPS默认443）后，会尝试与服务器建立TCP连接。</li>
<li>这通过三次握手 (Three-way Handshake)完成：<ol>
<li><strong>SYN:</strong> 浏览器发送一个SYN（同步）包到服务器，请求建立连接。</li>
<li><strong>SYN-ACK:</strong> 服务器收到SYN后，如果同意连接，会回复一个SYN-ACK（同步确认）包。</li>
<li><strong>ACK:</strong> 浏览器收到SYN-ACK后，发送一个ACK（确认）包给服务器。连接建立成功。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>TLS&#x2F;SSL握手 (如果是HTTPS):</strong></p>
<ul>
<li>如果URL是HTTPS协议，在TCP连接建立后，还需要进行TLS&#x2F;SSL握手以建立安全信道：<ol>
<li><strong>Client Hello:</strong> 浏览器发送支持的加密套件、TLS版本、一个随机数等信息。</li>
<li><strong>Server Hello:</strong> 服务器选择一个加密套件、TLS版本，返回自己的数字证书和一个随机数。</li>
<li><strong>Certificate Verification:</strong> 浏览器验证服务器证书的有效性（是否由信任的CA签发、是否过期、域名是否匹配）。</li>
<li><strong>Key Exchange:</strong> 浏览器生成另一个随机数（预主密钥），用服务器证书中的公钥加密后发送给服务器。</li>
<li><strong>Session Keys Generated:</strong> 双方根据三个随机数和协商的算法，生成对称的会话密钥，用于后续通信加密。</li>
<li><strong>Finished:</strong> 双方互相发送加密的“Finished”消息，确认握手完成。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>发送HTTP(S)请求:</strong></p>
<ul>
<li>TCP（和TLS）连接建立后，浏览器构造并发送一个HTTP请求报文。</li>
<li>报文包含：请求行（方法GET&#x2F;POST等，路径，HTTP版本）、请求头（<code>Host</code>, <code>User-Agent</code>, <code>Accept</code>, <code>Cookie</code>, <code>Referer</code>, 以及前面提到的缓存验证头<code>If-Modified-Since</code>&#x2F;<code>If-None-Match</code>等）、以及可选的请求体（POST请求的数据）。</li>
</ul>
</li>
<li><p><strong>服务器处理请求并响应:</strong></p>
<ul>
<li>服务器（如Nginx, Apache）接收到请求。</li>
<li>Web服务器可能将请求转交给应用服务器（如Node.js, Tomcat, PHP）。</li>
<li>后端代码执行，可能查询数据库、处理业务逻辑。</li>
<li>服务器生成一个HTTP响应报文。</li>
<li>报文包含：状态行（HTTP版本，状态码如 <code>200 OK</code>, <code>304 Not Modified</code>, <code>404 Not Found</code>等）、响应头（<code>Content-Type</code>, <code>Content-Length</code>, <code>Set-Cookie</code>, 以及缓存控制头<code>Cache-Control</code>, <code>ETag</code>, <code>Last-Modified</code>等）、以及响应体（通常是HTML内容，但也可能是CSS, JS, 图片等）。</li>
</ul>
</li>
<li><p><strong>浏览器接收并处理响应:</strong></p>
<ul>
<li>浏览器接收HTTP响应。</li>
<li><strong>检查状态码:</strong> 如果是<code>304 Not Modified</code>，浏览器直接从缓存加载资源。如果是<code>200 OK</code>等成功状态码，则处理响应体。如果是重定向（3xx），浏览器会根据<code>Location</code>头发出新的请求。如果是错误（4xx, 5xx），可能会显示错误页面。</li>
<li>处理响应体 (以HTML为例):<ul>
<li>浏览器根据响应头中的<code>Content-Type</code>（例如 <code>text/html</code>）来决定如何处理响应体。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>渲染页面:</strong> 这是浏览器内部非常复杂的过程，大致分为：</p>
<ul>
<li><strong>解析HTML (Parsing HTML):</strong> 浏览器将接收到的HTML文本解析成<strong>DOM (Document Object Model)</strong> 树。这是一个基于节点的对象表示，反映了HTML的结构。HTML解析器是<strong>渐进式</strong>的，边接收边解析。</li>
<li><strong>解析CSS (Parsing CSS):</strong> 在解析HTML时，如果遇到<code>&lt;link&gt;</code>标签引入外部CSS文件，或<code>&lt;style&gt;</code>标签内的CSS，浏览器会异步请求并解析CSS，构建<strong>CSSOM (CSS Object Model)</strong> 树。CSSOM表示了所有元素的样式信息。</li>
<li><strong>构建渲染树 (Render Tree Construction):</strong> 浏览器将DOM树和CSSOM树结合起来，生成<strong>渲染树 (Render Tree)</strong>。渲染树只包含<strong>需要显示</strong>的节点（例如<code>display: none</code>的节点会被排除）以及它们的计算后样式。</li>
<li><strong>布局 (Layout &#x2F; Reflow):</strong> 浏览器根据渲染树和视口（viewport）大小，计算每个节点在屏幕上的<strong>确切位置和尺寸</strong>。这个过程称为布局或回流（Reflow）。布局是一个<strong>全局</strong>过程，一个节点的改变可能影响其他节点。</li>
<li><strong>绘制 (Painting &#x2F; Repaint):</strong> 浏览器根据渲染树和布局信息，将每个节点绘制成屏幕上的<strong>实际像素</strong>。绘制通常发生在多个图层（Layers）上。这个过程称为绘制或重绘（Repaint）。</li>
<li><strong>合成 (Compositing):</strong> 浏览器将绘制好的各个图层按照正确的顺序（考虑<code>z-index</code>等）合并、显示在屏幕上。对于有特定属性（如<code>transform</code>, <code>opacity</code>）的元素，浏览器可能会将其提升到单独的合成层（Compositor Layer），由GPU加速处理，这样它们的变换就不会触发整个页面的重绘或回流，性能更好。</li>
</ul>
</li>
<li><p><strong>JavaScript执行:</strong></p>
<ul>
<li>在HTML解析过程中，如果遇到<code>&lt;script&gt;</code>标签（没有<code>async</code>或<code>defer</code>属性），HTML解析会<strong>暂停</strong>，浏览器会请求（如果是外部脚本）、解析并执行JavaScript代码。</li>
<li>JavaScript代码可以<strong>修改DOM和CSSOM</strong>（例如 <code>document.getElementById().style.color = &#39;red&#39;</code> 或 <code>document.createElement()</code>)。这些修改可能会<strong>触发新的回流和重绘</strong>。</li>
<li><code>defer</code>属性会让脚本在HTML解析完成后、<code>DOMContentLoaded</code>事件触发前按顺序执行。</li>
<li><code>async</code>属性会让脚本异步下载并在下载完成后立即执行，不保证顺序，且可能在HTML解析未完成时执行。它们都不阻塞HTML解析。</li>
</ul>
</li>
<li><p><strong>页面加载完成:</strong></p>
<ul>
<li>当所有资源（HTML, CSS, JS, 图片等）加载完成，并且所有<code>defer</code>脚本执行完毕后，浏览器会触发<code>window</code>的<code>load</code>事件。此时，页面完全渲染完成。</li>
</ul>
</li>
</ol>
<h4 id="HTTP-vs-HTTPS-的区别："><a href="#HTTP-vs-HTTPS-的区别：" class="headerlink" title="HTTP vs. HTTPS 的区别："></a><strong>HTTP vs. HTTPS 的区别：</strong></h4><p>主要区别在于<strong>安全性</strong>：</p>
<ol>
<li><p>安全性:</p>
<ul>
<li><p><strong>HTTP (HyperText Transfer Protocol):</strong> 是<strong>明文传输</strong>协议。数据在网络上传输时不加密，容易被中间人窃听、篡改。</p>
</li>
<li><p>HTTPS (HyperText Transfer Protocol Secure):是在HTTP的基础上加入了SSL&#x2F;TLS加密层的安全协议。它提供了：</p>
<ul>
<li><strong>数据加密 (Confidentiality):</strong> 通信内容被加密，第三方无法直接读取。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><strong>数据完整性 (Integrity):</strong> 通过校验机制确保数据在传输过程中未被篡改。<ul>
<li><strong>身份认证 (Authentication):</strong> 通过服务器证书验证网站的真实身份，防止钓鱼网站。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>端口号:</p>
<ul>
<li>HTTP默认使用<strong>80</strong>端口。</li>
<li>HTTPS默认使用<strong>443</strong>端口。</li>
</ul>
</li>
<li><p>连接过程:</p>
<ul>
<li>HTTPS在建立TCP连接后，需要进行额外的<strong>TLS&#x2F;SSL握手</strong>过程来协商加密密钥和验证服务器身份。HTTP则不需要。</li>
</ul>
</li>
<li><p>证书:</p>
<ul>
<li>HTTPS需要向**证书颁发机构（CA）**申请数字证书来证明服务器身份。HTTP不需要。</li>
</ul>
</li>
<li><p>性能:</p>
<ul>
<li>理论上，HTTPS由于涉及加解密和握手过程，会比HTTP稍微慢一点，并消耗更多的服务器资源。但现代CPU对加解密优化得很好，并且可以通过HTTP&#x2F;2等协议优化，这种性能差异通常不显著，安全性带来的好处远大于这点开销。</li>
</ul>
</li>
</ol>
<h4 id="请你说说实现元素水平居中和垂直居中的常用方法有哪些？"><a href="#请你说说实现元素水平居中和垂直居中的常用方法有哪些？" class="headerlink" title="请你说说实现元素水平居中和垂直居中的常用方法有哪些？"></a><strong>请你说说实现元素水平居中和垂直居中的常用方法有哪些？</strong></h4><p><strong>1. Flexbox (弹性布局 - 最常用、最推荐)</strong></p>
<ul>
<li><p><strong>适用场景:</strong> 对块级或行内块级子元素进行居中，无论是否知道子元素尺寸。</p>
</li>
<li><p>方法:在父容器上设置：CSS</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/* 水平居中 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: center;    <span class="comment">/* 垂直居中 */</span></span><br><span class="line">  <span class="comment">/* 可能需要设置父容器高度，例如: min-height: 100vh; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点:</strong> 代码简洁、语义化、功能强大，兼容性好。</p>
</li>
</ul>
<p><strong>2. Grid (网格布局 - 功能强大)</strong></p>
<ul>
<li><p><strong>适用场景:</strong> 类似于Flexbox，特别适合更复杂的二维布局，居中只是其能力之一。</p>
<p>使用 <code>justify-content</code> 和 <code>align-content</code> - 针对网格本身在容器中的对齐:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/* 水平居中网格项(如果只有一个)或整个网格 */</span></span><br><span class="line">  <span class="attribute">align-content</span>: center;   <span class="comment">/* 垂直居中网格项(如果只有一个)或整个网格 */</span></span><br><span class="line">  <span class="comment">/* 可能需要设置父容器高度 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点:</strong> 非常强大，尤其适合二维布局，代码同样简洁。</p>
</li>
</ul>

  </div>
  
    <div class="tags">
    <span><i class="fa fa-tags"></i> Tags</span>
      
        <ul class="post-tag-list" itemprop="keywords"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" rel="tag">八股文</a></li></ul>
      
    </div>
  

</article>

<!-- Comments -->

<!-- End Comments --></section>
    <footer id="footer" role="contentinfo">
    <div>&copy; 2025 <a href="/">DayBreak</a>.
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Designed by <a href="http://rainylog.com" target="_blank">Rainy.</a>
	</div>
</footer><!-- end #footer -->

  </div>
  
<script src="/lib/fancybox/dist/jquery.fancybox.min.js"></script>


  
<script src="/js/helper.js"></script>

  
<script src="/js/_third-party/gitment.js"></script>

</body>
</html>