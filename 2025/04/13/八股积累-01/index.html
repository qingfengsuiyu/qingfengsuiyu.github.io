<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>八股积累-01 | DayBreak</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="八股积累01:1.script标签的async和defer属性“script标签的async和defer属性都用于优化JavaScript加载执行过程，但它们的行为有明显区别：  defer：脚本会并行下载，但会等到HTML解析完成后，DOMContentLoaded事件前执行，保持脚本的执行顺序 async：脚本会并行下载，下载完成后立即执行，不保证执行顺序，也不等待HTML解析完成  实际应用">
<meta property="og:type" content="article">
<meta property="og:title" content="八股积累-01">
<meta property="og:url" content="http://example.com/2025/04/13/%E5%85%AB%E8%82%A1%E7%A7%AF%E7%B4%AF-01/index.html">
<meta property="og:site_name" content="DayBreak">
<meta property="og:description" content="八股积累01:1.script标签的async和defer属性“script标签的async和defer属性都用于优化JavaScript加载执行过程，但它们的行为有明显区别：  defer：脚本会并行下载，但会等到HTML解析完成后，DOMContentLoaded事件前执行，保持脚本的执行顺序 async：脚本会并行下载，下载完成后立即执行，不保证执行顺序，也不等待HTML解析完成  实际应用">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-04-13T07:33:29.000Z">
<meta property="article:modified_time" content="2025-04-13T07:42:34.910Z">
<meta property="article:author" content="Xiaoyi Hao">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="DayBreak" type="application/atom+xml">
  
  
  
  
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0.css">

  
<link rel="stylesheet" href="/lib/fancybox/dist/jquery.fancybox.min.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<script src="/lib/jquery/dist/jquery.min.js"></script>

  
  
  
  
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="wrapper">
    <header id="header" class="clearfix">
	<a id="logo" href="/" title="DayBreak">DayBreak</a>
	
	<nav id="nav-menu" class="clearfix">
		<form id="search" method="post" action="./" role="search">
			<input id="search-input" type="text" name="s" class="inputbox" value="Search" onfocus="if (value =='Search'){value =''}" onblur="if (value ==''){value='Search'}">
		</form>
		<ul>
      
				
        <li><a class="main-nav-link" href="/">Home</a></li>
      
				
        <li><a class="main-nav-link" href="/archives">Archives</a></li>
      
		</ul>
	</nav>
</header>
    <section id="main" class="clearfix"><article class="post-detail">
  <h1 class="post-title"><a href="/">八股积累-01</a></h1>
  <ul class="post-meta">
  <li><i class="fa fa-user"></i> Author Xiaoyi Hao</li>
  <li><i class="fa fa-calendar"></i> Date Apr 13</li>
  <li><i class="fa fa-folder"></i> Categories
  
    no_categories
  
  </li>
</ul>
  <div class="post-content">
      
      <h4 id="八股积累01"><a href="#八股积累01" class="headerlink" title="八股积累01:"></a><strong>八股积累01:</strong></h4><h5 id="1-script标签的async和defer属性"><a href="#1-script标签的async和defer属性" class="headerlink" title="1.script标签的async和defer属性"></a><strong>1.script标签的async和defer属性</strong></h5><p>“script标签的async和defer属性都用于<strong>优化JavaScript加载执行过程</strong>，但它们的行为有明显区别：</p>
<ul>
<li><strong>defer</strong>：脚本会并行下载，<strong>但会等到HTML解析完成后</strong>，DOMContentLoaded事件前执行，<strong>保持脚本的执行顺序</strong></li>
<li><strong>async</strong>：脚本会并行下载，下载完成后立即执行，<strong>不保证执行顺序</strong>，<strong>也不等待HTML解析完成</strong></li>
</ul>
<p>实际应用中，defer适合那些需要访问完整DOM或有依赖关系的脚本，async更适合独立的第三方脚本，如分析工具等。”</p>
<h5 id="2-同步和异步操作"><a href="#2-同步和异步操作" class="headerlink" title="2.同步和异步操作"></a><strong>2.同步和异步操作</strong></h5><p><strong>在JavaScript中，同步操作按顺序执行，每个操作完成后才执行下一个，这可能导致长时间操作阻塞界面。而异步操作允许代码继续执行而不等待操作完成，结果通过回调函数、Promise或async&#x2F;await处理。</strong></p>
<p><strong>常见的异步操作包括：AJAX请求、setTimeout&#x2F;setInterval、事件监听和文件操作等。</strong></p>
<h5 id="3-对于DOM的操作方法"><a href="#3-对于DOM的操作方法" class="headerlink" title="3.对于DOM的操作方法"></a><strong>3.对于DOM的操作方法</strong></h5><ul>
<li>元素选择：getElementById、querySelector、querySelector<strong>All</strong>等</li>
<li>元素创建：create<strong>Element</strong>、createTextNode</li>
<li>元素修改：appendChild、removeChild、replaceChild、insertBefore</li>
<li>属性操作：<strong>get</strong>Attribute、setAttribute、<strong>remove</strong>Attribute</li>
<li>样式操作：element.style或classList.add&#x2F;remove&#x2F;toggle</li>
<li>内容操作：innerHTML、textContent、innerText</li>
</ul>
<h5 id="4-块级元素和行内元素"><a href="#4-块级元素和行内元素" class="headerlink" title="4.块级元素和行内元素"></a><strong>4.块级元素和行内元素</strong></h5><p><strong>块级元素特点：</strong></p>
<ul>
<li><strong>独占一行，默认宽度为父容器的100%</strong></li>
<li><strong>可以设置width、height、margin和padding</strong></li>
<li><strong>典型的块级元素有：div、p、h1-h6、ul、ol、li、table、form等</strong></li>
</ul>
<p><strong>行内元素特点：</strong></p>
<ul>
<li><strong>不会独占一行，多个行内元素会在同一行显示</strong></li>
<li><strong>宽高由内容决定，设置width和height无效</strong></li>
<li>margin和padding只在水平方向有效</li>
<li><strong>代表元素：span、a、strong、em、img、input等</strong></li>
</ul>
<h5 id="5-盒模型"><a href="#5-盒模型" class="headerlink" title="5.盒模型"></a><strong>5.盒模型</strong></h5><p><strong>标准盒模型(content-box)<strong>和</strong>IE盒模型(border-box)<strong>是CSS中</strong>两种不同的盒模型</strong>。</p>
<p>**标准盒模型下，元素的宽高仅包括内容区(content)，不包括padding、border和margin。**即：</p>
<ul>
<li>实际宽度 &#x3D; width + padding-left + padding-right + border-left + border-right</li>
<li>实际高度 &#x3D; height + padding-top + padding-bottom + border-top + border-bottom</li>
</ul>
<p>**而IE盒模型(border-box)中，元素的宽高包括内容区、padding和border，但不包括margin。**即：</p>
<ul>
<li>width &#x3D; 内容宽度 + padding-left + padding-right + border-left + border-right</li>
<li>height &#x3D; 内容高度 + padding-top + padding-bottom + border-top + border-bottom</li>
</ul>
<h5 id="6-行内元素可以设置宽高吗？怎么设置"><a href="#6-行内元素可以设置宽高吗？怎么设置" class="headerlink" title="6.行内元素可以设置宽高吗？怎么设置"></a><strong>6.行内元素可以设置宽高吗？怎么设置</strong></h5><p><strong>行内元素(inline)默认情况下不能设置宽高，其尺寸由内容决定</strong>。但有两种方式可以让行内元素接受宽高设置：</p>
<p><strong>1.将行内元素转换为块级或行内块元素：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block; <span class="comment">/* 或 inline-block */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.将行内元素设置为flex项目：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际开发中，我更倾向于使用<code>display: inline-block</code>，因为它既可以设置宽高，又不会破坏元素的行内特性，不会强制换行。</p>
<h5 id="7-讲讲position"><a href="#7-讲讲position" class="headerlink" title="7.讲讲position"></a><strong>7.讲讲position</strong></h5><p>CSS的position属性定义元素的定位方式，主要有五个值：</p>
<ol>
<li><code>static</code>(默认值)：元素按照正常文档流进行布局，<strong>top、right、bottom、left和z-index属性无效</strong>。</li>
<li><code>relative</code>：<strong>元素相对于其正常位置进行定位，不脱离文档流，不影响其他元素的布局。</strong></li>
<li><code>absolute</code>：<strong>元素脱离文档流，相对于最近的非static定位祖先元素进行定位。如果没有这样的祖先元素，则相对于初始包含块(通常是viewport)。</strong></li>
<li><code>fixed</code>：<strong>元素脱离文档流，相对于浏览器视口(viewport)进行定位，即使页面滚动也保持固定位置</strong>。</li>
<li><code>sticky</code>：<strong>元素在滚动到特定位置前相当于relative，之后表现为fixed。是relative和fixed的混合</strong>。</li>
</ol>
<h5 id="8-元素水平居中的方式"><a href="#8-元素水平居中的方式" class="headerlink" title="8.元素水平居中的方式"></a><strong>8.元素水平居中的方式</strong></h5><p><strong>对于行内元素或行内块元素：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于固定宽度的块级元素</strong>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用flexbox：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用grid：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">justify-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-讲讲flex"><a href="#9-讲讲flex" class="headerlink" title="9.讲讲flex"></a><strong>9.讲讲flex</strong></h5><p>Flexbox(弹性盒子)是CSS3中的一种布局模式，专为创建更加灵活的页面布局而设计。主要特点：</p>
<p>核心概念：</p>
<ul>
<li>Flex容器(container)：设置<code>display: flex</code>的元素</li>
<li>Flex项目(items)：Flex容器的子元素</li>
<li>主轴(main axis)和交叉轴(cross axis)</li>
</ul>
<p>容器属性：</p>
<ul>
<li><code>flex-direction</code>: 决定主轴方向(row&#x2F;column)</li>
<li><code>flex-wrap</code>: 控制项目是否换行</li>
<li><code>justify-content</code>: 主轴上的对齐方式</li>
<li><code>align-items</code>: 交叉轴上的对齐方式</li>
<li><code>align-content</code>: 多行对齐方式</li>
</ul>
<h5 id="10-var-a-1-function-a-console-log-a-输出？"><a href="#10-var-a-1-function-a-console-log-a-输出？" class="headerlink" title="10. var a&#x3D;1;function a(){} console.log(a)输出？"></a><strong>10. var a&#x3D;1;function a(){} console.log(a)输出？</strong></h5><p>这段代码输出的结果是<code>1</code>。</p>
<p>这涉及到JavaScript中的变量提升和函数声明提升的机制：</p>
<ol>
<li>函数声明<code>function a()&#123;&#125;</code>会被整体提升到作用域顶部</li>
<li>变量声明<code>var a</code>也会被提升，但赋值不会</li>
<li>同名的函数声明和变量声明，函数声明优先级更高</li>
<li>执行到<code>var a=1</code>时，变量a被赋值为1，覆盖了之前的函数引用</li>
</ol>
<p>代码执行顺序等同于：</p>
<p>javascript</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 函数声明提升</span></span><br><span class="line"><span class="keyword">var</span> a;         <span class="comment">// 变量声明提升（此时a已经是函数）</span></span><br><span class="line">a = <span class="number">1</span>;         <span class="comment">// 赋值操作，a变成了数字1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure>

<p>这个问题考察了JavaScript中函数声明和变量声明的提升机制以及它们的优先级关系。理解这些规则对于避免代码中的潜在问题很重要。</p>
<h5 id="11-判断数据类型的方法-根据英文名字记忆"><a href="#11-判断数据类型的方法-根据英文名字记忆" class="headerlink" title="11. 判断数据类型的方法(根据英文名字记忆)"></a><strong>11. 判断数据类型的方法(根据英文名字记忆)</strong></h5><p><strong>1.typeof运算符</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>;           <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;hello&quot;</span>;      <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>;         <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>;    <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>();     <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42n</span>;          <span class="comment">// &quot;bigint&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;;           <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> [];           <span class="comment">// &quot;object&quot; (注意数组返回&quot;object&quot;)</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>;         <span class="comment">// &quot;object&quot; (这是一个历史遗留bug)</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;; <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.instanceof运算符</strong>：检测<strong>对象是否是某个构造函数的实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span>;  <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>3.Object.prototype.toString.call()</strong>：最准确的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">42</span>);        <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&quot;hello&quot;</span>);   <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>);      <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>); <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>);      <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;);        <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]);        <span class="comment">// &quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>4.Array.isArray()</strong>：专們用于检测数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([]);  <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;&#125;);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h5 id="12-闭包的实际应用"><a href="#12-闭包的实际应用" class="headerlink" title="12.闭包的实际应用"></a><strong>12.闭包的实际应用</strong></h5><p>闭包是指一个函数能够访问并记住其词法作用域，即使该函数在其词法作用域之外执行。实际应用包括：</p>
<p><strong>1.数据私有化&#x2F;封装</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;  <span class="comment">// 私有变量</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; count++; &#125;,</span><br><span class="line">        <span class="attr">decrement</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; count--; &#125;,</span><br><span class="line">        <span class="attr">getCount</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">createCounter</span>();</span><br><span class="line">counter.<span class="title function_">increment</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="title function_">getCount</span>()); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 无法直接访问count变量</span></span><br></pre></td></tr></table></figure>

<p><strong>2.模块模式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calculator = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 私有变量和函数</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x</span>) &#123; result += x; &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">subtract</span>(<span class="params">x</span>) &#123; result -= x; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公共API</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add,</span><br><span class="line">        subtract,</span><br><span class="line">        <span class="attr">getResult</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">calculator.<span class="title function_">add</span>(<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(calculator.<span class="title function_">getResult</span>()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p><strong>3.函数工厂</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createMultiplier</span>(<span class="params">multiplier</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * multiplier;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> double = <span class="title function_">createMultiplier</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> triple = <span class="title function_">createMultiplier</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">double</span>(<span class="number">5</span>)); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">triple</span>(<span class="number">5</span>)); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p><strong>4.setTimeout中保存循环变量</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i), <span class="number">100</span>); <span class="comment">// 输出：3,3,3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用闭包解决</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">index</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(index), <span class="number">100</span>); <span class="comment">// 输出：0,1,2</span></span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代解决方案：使用let替代var</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i), <span class="number">100</span>); <span class="comment">// 输出：0,1,2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5.事件处理和回调</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupButtonActions</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> buttons = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    buttons.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">button, index</span>) &#123;</span><br><span class="line">        button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 闭包可以访问index和button</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Button <span class="subst">$&#123;index&#125;</span> clicked`</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="13-写判读值相同isEqual-a-b-函数，a和b的数据类型不一定一样"><a href="#13-写判读值相同isEqual-a-b-函数，a和b的数据类型不一定一样" class="headerlink" title="13.写判读值相同isEqual(a,b)函数，a和b的数据类型不一定一样"></a><strong>13.写判读值相同isEqual(a,b)函数，a和b的数据类型不一定一样</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isEqual</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.判断基本类型或引用相同</span></span><br><span class="line">  <span class="keyword">if</span> (a === b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.如果其中一个是null或不是对象，且已经不相等，返回false</span></span><br><span class="line">  <span class="keyword">if</span> (a === <span class="literal">null</span> || b === <span class="literal">null</span> || <span class="keyword">typeof</span> a !== <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> b !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.处理日期对象</span></span><br><span class="line">  <span class="keyword">if</span> (a <span class="keyword">instanceof</span> <span class="title class_">Date</span> &amp;&amp; b <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">getTime</span>() === b.<span class="title function_">getTime</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.处理正则表达式</span></span><br><span class="line">  <span class="keyword">if</span> (a <span class="keyword">instanceof</span> <span class="title class_">RegExp</span> &amp;&amp; b <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">toString</span>() === b.<span class="title function_">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.检查是否为数组</span></span><br><span class="line">  <span class="keyword">const</span> isArrayA = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(a);</span><br><span class="line">  <span class="keyword">const</span> isArrayB = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(b);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个是数组一个不是，返回false</span></span><br><span class="line">  <span class="keyword">if</span> (isArrayA !== isArrayB) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理数组</span></span><br><span class="line">  <span class="keyword">if</span> (isArrayA &amp;&amp; isArrayB) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="property">length</span> !== b.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isEqual</span>(a[i], b[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6.处理普通对象</span></span><br><span class="line">  <span class="keyword">const</span> keysA = <span class="title class_">Object</span>.<span class="title function_">keys</span>(a);</span><br><span class="line">  <span class="keyword">const</span> keysB = <span class="title class_">Object</span>.<span class="title function_">keys</span>(b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (keysA.<span class="property">length</span> !== keysB.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保b中包含a的所有键，并且对应值相等</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keysA) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!keysB.<span class="title function_">includes</span>(key) || !<span class="title function_">isEqual</span>(a[key], b[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CSS-布局-Layout-vs-定位-Positioning-属性对比"><a href="#CSS-布局-Layout-vs-定位-Positioning-属性对比" class="headerlink" title="CSS 布局 (Layout) vs 定位 (Positioning) 属性对比"></a><strong>CSS 布局 (Layout) vs 定位 (Positioning) 属性对比</strong></h4><table>
<thead>
<tr>
<th><strong>概念分类</strong></th>
<th><strong>属性 (Property)</strong></th>
<th><strong>主要作用 (Main Purpose)</strong></th>
<th><strong>关键值&#x2F;说明 (Key Values&#x2F;Notes)</strong></th>
<th><strong>对文档流影响 (Impact on Document Flow)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>布局 (Layout)</strong></td>
<td><code>display</code></td>
<td>定义元素的基本框类型和布局方式（块级、内联、弹性、网格等）</td>
<td><code>block</code>, <code>inline</code>, <code>inline-block</code>, <code>flex</code>, <code>grid</code>, <code>none</code>, <code>table</code> 等</td>
<td><strong>根本性影响</strong>。决定元素如何参与或不参与文档流，是否独占一行等。</td>
</tr>
<tr>
<td></td>
<td><code>width</code>, <code>height</code> (及 <code>min/max</code> 变体)</td>
<td>设置元素的尺寸</td>
<td>像素 (<code>px</code>), 百分比 (<code>%</code>), <code>auto</code>, <code>vw</code>&#x2F;<code>vh</code> 等</td>
<td><strong>影响</strong>。决定元素在流中所占据的空间大小。</td>
</tr>
<tr>
<td></td>
<td><code>margin</code></td>
<td>设置元素<strong>外</strong>边距，控制元素之间的间距</td>
<td>可以是正负值，像素，百分比等。<code>auto</code> 可用于块级元素水平居中。</td>
<td><strong>影响</strong>。改变元素周围的空间，从而影响相邻元素在流中的位置。</td>
</tr>
<tr>
<td></td>
<td><code>padding</code></td>
<td>设置元素<strong>内</strong>边距，控制内容与边框的距离</td>
<td>通常是正值，像素，百分比等。</td>
<td><strong>影响</strong>。改变元素内部空间，可能影响元素（在 <code>content-box</code>下）的总尺寸，但不改变其在流中的基本性质。</td>
</tr>
<tr>
<td></td>
<td><code>box-sizing</code></td>
<td>定义 <code>width</code> 和 <code>height</code> 如何计算（是否包含 padding 和 border）</td>
<td><code>content-box</code> (默认), <code>border-box</code></td>
<td><strong>影响布局计算</strong>，但不直接改变元素的流行为（块级还是内联等）。</td>
</tr>
<tr>
<td></td>
<td><code>float</code></td>
<td>使元素脱离正常流，向左或右移动，允许文本或其他内联元素环绕</td>
<td><code>left</code>, <code>right</code>, <code>none</code></td>
<td><strong>部分脱离</strong>。元素本身仍在布局中（影响父容器高度等），但其位置脱离常规流，后续非 <code>clear</code> 元素会环绕它。</td>
</tr>
<tr>
<td></td>
<td><code>clear</code></td>
<td>指定元素旁边是否允许浮动元素</td>
<td><code>left</code>, <code>right</code>, <code>both</code>, <code>none</code></td>
<td><strong>影响</strong>。强制元素移动到浮动元素的下方，恢复正常流的部分顺序。</td>
</tr>
<tr>
<td></td>
<td>Flexbox 属性 (如 <code>flex-direction</code>, <code>justify-content</code>, <code>align-items</code>)</td>
<td>（用于 <code>display: flex</code> 容器）控制弹性项目在容器内的排列、对齐和分布</td>
<td>多种值，用于控制主轴、交叉轴对齐，换行等</td>
<td><strong>定义容器内项目的新文档流</strong>（弹性流）。</td>
</tr>
<tr>
<td></td>
<td>Grid 属性 (如 <code>grid-template-columns</code>, <code>grid-template-rows</code>, <code>gap</code>)</td>
<td>（用于 <code>display: grid</code> 容器）定义二维网格结构，并将项目放入网格单元</td>
<td>定义列宽、行高、区域、间距等</td>
<td><strong>定义容器内项目的新文档流</strong>（网格流）。</td>
</tr>
<tr>
<td></td>
<td><code>overflow</code></td>
<td>控制内容超出元素框时的处理方式</td>
<td><code>visible</code>, <code>hidden</code>, <code>scroll</code>, <code>auto</code></td>
<td><strong>主要影响内容呈现</strong>，一般不改变元素在流中的位置和大小（除非 <code>visible</code> 导致内容溢出影响后续元素）。</td>
</tr>
<tr>
<td></td>
<td><code>vertical-align</code></td>
<td>设置行内元素或表格单元格的垂直对齐方式</td>
<td><code>baseline</code>, <code>top</code>, <code>middle</code>, <code>bottom</code>, 长度值等</td>
<td><strong>影响</strong>。调整元素在<strong>行框 (line box)</strong> 或表格单元格内的垂直位置，属于流内微调。</td>
</tr>
<tr>
<td><strong>定位 (Positioning)</strong></td>
<td><code>position</code></td>
<td><strong>定义元素的定位机制</strong></td>
<td><code>static</code> (默认), <code>relative</code>, <code>absolute</code>, <code>fixed</code>, <code>sticky</code></td>
<td><strong>关键性影响</strong>。<code>relative</code> 不脱离但可偏移；<code>absolute</code>&#x2F;<code>fixed</code> 完全脱离；<code>sticky</code> 条件性脱离&#x2F;固定。</td>
</tr>
<tr>
<td></td>
<td><code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code></td>
<td>（当 <code>position</code> 非 <code>static</code> 时）<strong>设置定位元素相对于其参照物的偏移量</strong></td>
<td>长度值 (<code>px</code>, <code>%</code> 等), <code>auto</code></td>
<td><strong>不直接影响</strong>其他元素的常规文档流布局，仅移动该元素本身。脱离流的元素不再占据原始空间。</td>
</tr>
<tr>
<td></td>
<td><code>z-index</code></td>
<td>（当 <code>position</code> 非 <code>static</code> 时）<strong>设置定位元素的堆叠顺序（前后层次）</strong></td>
<td>整数 (可正可负), <code>auto</code></td>
<td><strong>不影响</strong>文档流布局，仅影响元素在 Z 轴（视觉前后）上的覆盖关系。</td>
</tr>
</tbody></table>
<p><strong>记忆小结：</strong></p>
<ul>
<li><strong>布局 (Layout)</strong> 属性更像是“规划师”，负责安排大家（元素）怎么站队、占多大地儿、彼此隔多远。它们主要在<strong>文档流内部</strong>工作，或者创建新的流上下文（Flex&#x2F;Grid）。</li>
<li><strong>定位 (Positioning)</strong> 属性更像是“调度员”，可以把某个特定的人（元素）叫出来，让他站到<strong>指定的位置</strong>，有时甚至可以让他“飞起来”（脱离地面&#x2F;文档流），或者叠在别人身上。<code>position</code> 是开启定位能力的总开关，<code>top/right/bottom/left</code> 是具体的坐标指令，<code>z-index</code> 是处理重叠时的前后顺序。</li>
</ul>
<h4 id="输入一个url会发生什么，尽量具体。"><a href="#输入一个url会发生什么，尽量具体。" class="headerlink" title="输入一个url会发生什么，尽量具体。"></a><strong>输入一个url会发生什么，尽量具体。</strong></h4><p><strong>我：</strong> 这个过程非常复杂，涉及浏览器、操作系统、网络协议等多个层面。我尝试尽可能详细地描述一下主要步骤：</p>
<ol>
<li><strong>用户输入与解析 (Input &amp; Parsing):</strong> 用户在浏览器地址栏输入 URL (Uniform Resource Locator)，比如 <code>https://www.example.com/path?query=1</code>。浏览器会解析这个 URL，识别出协议 (<code>https</code>)、域名 (<code>www.example.com</code>)、路径 (<code>/path</code>)、查询参数 (<code>?query=1</code>) 等。浏览器可能还会进行一些预处理，比如自动补全 <code>https://</code> 或者处理特殊字符。</li>
<li><strong>DNS 查询 (Domain Name System Lookup):</strong> 由于网络通信是基于 IP 地址的，浏览器需要将域名转换为对应的服务器 IP 地址。<ul>
<li><strong>浏览器缓存:</strong> 检查浏览器自身的 DNS 缓存。</li>
<li><strong>操作系统缓存:</strong> 检查操作系统的 DNS 缓存 (如 <code>hosts</code> 文件)。</li>
<li><strong>路由器缓存:</strong> 检查本地路由器的 DNS 缓存。</li>
<li><strong>ISP DNS 服务器:</strong> 向配置的本地 ISP (互联网服务提供商) 的 DNS 服务器发起递归查询请求。</li>
<li><strong>根域名服务器 -&gt; TLD 服务器 -&gt; 权威 DNS 服务器:</strong> ISP DNS 服务器会从根服务器开始，逐级查询顶级域名 (TLD, 如 <code>.com</code>) 服务器，最终找到负责 <code>example.com</code> 域名的权威 DNS 服务器，获取到 IP 地址。</li>
<li><strong>返回与缓存:</strong> 权威 DNS 服务器将 IP 地址返回给 ISP DNS 服务器，后者再返回给操作系统和浏览器，并进行缓存。</li>
</ul>
</li>
<li><strong>建立 TCP 连接 (TCP Connection Setup):</strong> 浏览器获取到 IP 地址后，需要与目标服务器建立 TCP 连接。这通常通过<strong>三次握手</strong>完成：<ul>
<li><strong>SYN:</strong> 浏览器（客户端）向服务器发送一个 SYN (Synchronize Sequence Numbers) 包，表示请求建立连接。</li>
<li><strong>SYN-ACK:</strong> 服务器收到 SYN 包后，如果同意连接，会回复一个 SYN-ACK (Synchronize-Acknowledgement) 包，表示确认收到请求并也请求建立连接。</li>
<li><strong>ACK:</strong> 浏览器收到 SYN-ACK 包后，再发送一个 ACK (Acknowledgement) 包给服务器，表示确认收到服务器的确认。至此，TCP 连接建立成功。</li>
</ul>
</li>
<li><strong>TLS&#x2F;SSL 握手 (If HTTPS):</strong> 如果 URL 是 <code>https</code> 协议，在 TCP 连接建立后，还需要进行 TLS (Transport Layer Security) &#x2F; SSL (Secure Sockets Layer) 握手，以建立加密信道：<ul>
<li>客户端发送 ClientHello (支持的加密套件、协议版本等)。</li>
<li>服务器回应 ServerHello (选定的加密套件、协议版本)，并发送其数字证书。</li>
<li>客户端验证证书的有效性（是否由受信任的 CA 颁发、是否过期、域名是否匹配等）。</li>
<li>（可能）客户端和服务器交换密钥信息（如使用 Diffie-Hellman 算法协商会话密钥）。</li>
<li>双方都生成会话密钥，并确认握手完成。之后的所有 HTTP 数据都将通过这个加密通道传输。</li>
</ul>
</li>
<li><strong>发送 HTTP(S) 请求 (Sending HTTP(S) Request):</strong> 浏览器构建一个 HTTP 请求报文，通过建立好的 TCP (和 TLS) 连接发送给服务器。请求报文通常包含：<ul>
<li><strong>请求行:</strong> 请求方法 (GET, POST等)、请求的资源路径 (<code>/path?query=1</code>)、HTTP 协议版本。</li>
<li><strong>请求头 (Headers):</strong> 包含各种附加信息，如 <code>Host</code> (目标域名)、<code>User-Agent</code> (浏览器标识)、<code>Accept</code> (可接受的内容类型)、<code>Cookie</code> (携带之前服务器设置的 Cookie)、<code>Connection: keep-alive</code> (建议保持 TCP 连接) 等。</li>
<li><strong>请求体 (Body):</strong> 对于 POST 请求等，会包含需要提交的数据。</li>
</ul>
</li>
<li><strong>服务器处理请求与响应 (Server Processing &amp; Response):</strong><ul>
<li>Web 服务器 (如 Nginx, Apache) 接收到请求。</li>
<li>根据请求路径和配置，可能将请求转发给后端应用服务器 (如 Node.js, Tomcat, PHP-FPM)。</li>
<li>后端应用处理业务逻辑，可能涉及数据库查询、调用其他服务等。</li>
<li>服务器构建一个 HTTP 响应报文，包含：<ul>
<li><strong>状态行:</strong> HTTP 协议版本、状态码 (如 <code>200 OK</code>, <code>404 Not Found</code>, <code>301 Moved Permanently</code>)、状态描述。</li>
<li><strong>响应头 (Headers):</strong> 如 <code>Content-Type</code> (响应体内容类型，如 <code>text/html</code>)、<code>Content-Length</code> (响应体大小)、<code>Set-Cookie</code> (要求浏览器设置 Cookie)、<code>Cache-Control</code> (缓存策略) 等。</li>
<li><strong>响应体 (Body):</strong> 实际的资源内容，如 HTML 文档、JSON 数据、图片等。</li>
</ul>
</li>
<li>服务器将响应报文通过 TCP 连接发送回浏览器。</li>
</ul>
</li>
<li><strong>浏览器接收与处理响应 (Browser Receiving &amp; Processing):</strong><ul>
<li>浏览器接收 HTTP 响应。</li>
<li><strong>解析 HTML:</strong> 如果响应类型是 <code>text/html</code>，浏览器开始解析 HTML 文档，构建 <strong>DOM (Document Object Model) 树</strong>。</li>
<li><strong>请求其他资源:</strong> 在解析 HTML 时，如果遇到外部资源引用（如 CSS 文件、JavaScript 文件、图片、字体），浏览器会<strong>并行或串行地</strong>发起新的 HTTP 请求去获取这些资源（过程类似步骤 2-6，但可能复用现有 TCP 连接 - HTTP Keep-Alive&#x2F;HTTP&#x2F;2 Multiplexing）。</li>
<li><strong>解析 CSS:</strong> 浏览器解析 CSS 文件（外部或内联样式），构建 <strong>CSSOM (CSS Object Model) 树</strong>。</li>
<li><strong>构建渲染树 (Render Tree):</strong> 结合 DOM 树和 CSSOM 树，创建渲染树。渲染树只包含需要显示的节点及其样式信息（<code>display: none</code> 的节点不会包含在内）。</li>
<li><strong>布局 (Layout &#x2F; Reflow):</strong> 根据渲染树，计算每个节点在屏幕上的精确位置和大小。</li>
<li><strong>绘制 (Paint &#x2F; Raster):</strong> 将渲染树的各个节点绘制成位图（像素）。浏览器可能会将页面分成多个层 (Layers) 来绘制。</li>
<li><strong>合成 (Composite):</strong> 将绘制好的各个层按照正确的顺序（考虑 <code>z-index</code> 等）合并到屏幕上显示。</li>
</ul>
</li>
<li><strong>JavaScript 执行:</strong><ul>
<li>在解析 HTML 时，如果遇到 <code>&lt;script&gt;</code> 标签（没有 <code>async</code> 或 <code>defer</code> 属性），HTML 解析会暂停，浏览器会下载（如果需要）并执行 JavaScript 代码。JS 代码可能会修改 DOM 或 CSSOM，这可能导致重新布局 (Reflow) 和重绘 (Repaint)。</li>
<li><code>defer</code> 的脚本会按顺序在 HTML 解析完成后、DOMContentLoaded 事件前执行。</li>
<li><code>async</code> 的脚本会在下载完成后立刻执行，可能在 HTML 解析完成前或后，执行顺序不确定，且会阻塞 HTML 解析。</li>
</ul>
</li>
<li><strong>页面加载完成与交互:</strong> 当所有资源（特别是初始渲染所需的）加载和处理完毕，页面显示完成。之后 JavaScript 可以响应用户的交互事件（点击、滚动、输入等）。</li>
</ol>
<h4 id="常见的tcp和udp协议"><a href="#常见的tcp和udp协议" class="headerlink" title="常见的tcp和udp协议"></a><strong>常见的tcp和udp协议</strong></h4><p><strong>我：</strong> 在 TCP&#x2F;IP 协议栈中，TCP 和 UDP 是传输层的两个主要协议。它们负责在网络中的应用程序之间传输数据。很多我们熟悉的上层应用协议都是基于它们构建的：</p>
<ul>
<li><strong>基于 TCP 的常见协议:</strong><ul>
<li><strong>HTTP&#x2F;HTTPS (HyperText Transfer Protocol &#x2F; Secure):</strong> 用于 Web 浏览器和 Web 服务器之间传输网页内容。</li>
<li><strong>FTP (File Transfer Protocol):</strong> 用于在网络上传输文件。</li>
<li><strong>SMTP (Simple Mail Transfer Protocol):</strong> 用于发送电子邮件。</li>
<li><strong>POP3 (Post Office Protocol version 3) &#x2F; IMAP (Internet Message Access Protocol):</strong> 用于接收电子邮件。</li>
<li><strong>SSH (Secure Shell):</strong> 用于安全的远程登录和执行命令。</li>
<li><strong>Telnet:</strong> 用于远程登录（不安全）。</li>
<li><strong>DNS:</strong> 虽然主要使用 UDP，但在需要传输大量数据（如区域传送）或要求可靠性时，也可以使用 TCP。</li>
</ul>
</li>
<li><strong>基于 UDP 的常见协议:</strong><ul>
<li><strong>DNS (Domain Name System):</strong> 主要用于域名到 IP 地址的快速查询。</li>
<li><strong>DHCP (Dynamic Host Configuration Protocol):</strong> 用于自动分配 IP 地址给网络中的设备。</li>
<li><strong>SNMP (Simple Network Management Protocol):</strong> 用于网络设备管理和监控。</li>
<li><strong>TFTP (Trivial File Transfer Protocol):</strong> 一个简化的文件传输协议。</li>
<li><strong>VoIP (Voice over IP):</strong> 很多实时语音通话应用使用 UDP 以减少延迟。</li>
<li><strong>在线游戏:</strong> 很多实时在线游戏的数据传输（如玩家位置同步）倾向于使用 UDP 以获得更快的响应。</li>
<li><strong>视频&#x2F;音频流:</strong> 一些实时流媒体协议（如 RTP）基于 UDP。</li>
<li><strong>NTP (Network Time Protocol):</strong> 用于同步网络中计算机的时间。</li>
<li><strong>QUIC (Quick UDP Internet Connections):</strong> HTTP&#x2F;3 使用的基础协议。</li>
</ul>
</li>
</ul>
<h4 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a><strong>tcp和udp的区别</strong></h4><p><strong>我：</strong> TCP (Transmission Control Protocol) 和 UDP (User Datagram Protocol) 是传输层的两个核心协议，它们的主要区别在于设计目标和提供的服务特性：</p>
<ol>
<li><strong>连接性:</strong><ul>
<li><strong>TCP:</strong> <strong>面向连接</strong>的协议。在数据传输前，必须先通过三次握手建立连接；传输结束后，需要通过四次挥手断开连接。</li>
<li><strong>UDP:</strong> <strong>无连接</strong>的协议。发送数据前不需要建立连接，直接将数据报 (Datagram) 发送出去。</li>
</ul>
</li>
<li><strong>可靠性:</strong><ul>
<li><strong>TCP:</strong> <strong>可靠的</strong>协议。通过序列号、确认应答 (ACK)、超时重传、数据校验等机制，确保数据能够<strong>有序、无差错、不丢失、不重复</strong>地到达目的地。</li>
<li><strong>UDP:</strong> <strong>不可靠的</strong>（或称“尽力而为”的）协议。不保证数据能否到达、是否按序到达、是否完整。它只负责将数据报发送出去，后续的可靠性需要应用层自己处理（如果需要的话）。</li>
</ul>
</li>
<li><strong>数据传输方式:</strong><ul>
<li><strong>TCP:</strong> 基于<strong>字节流 (Byte Stream)</strong>。数据没有明显的边界，像水流一样传输。接收方需要根据应用逻辑来划分数据。</li>
<li><strong>UDP:</strong> 基于<strong>数据报 (Datagram)</strong>。每个 UDP 包都是一个独立的消息单元，有明确的边界。接收方一次接收一个完整的报文。</li>
</ul>
</li>
<li><strong>效率与开销:</strong><ul>
<li><strong>TCP:</strong> 开销较大。因为需要维护连接状态、序列号、确认、重传、流量控制、拥塞控制等，头部信息也更复杂（至少 20 字节）。传输效率相对较低。</li>
<li><strong>UDP:</strong> 开销小。头部简单（固定 8 字节），没有复杂的控制机制。传输效率高，速度快。</li>
</ul>
</li>
<li><strong>流量控制与拥塞控制:</strong><ul>
<li><strong>TCP:</strong> 具备<strong>流量控制</strong>（使用滑动窗口，防止发送方过快地发送数据淹没接收方）和<strong>拥塞控制</strong>（根据网络状况动态调整发送速率，避免加剧网络拥堵）。</li>
<li><strong>UDP:</strong> <strong>没有</strong>流量控制和拥塞控制。发送方会以恒定速率（或应用层决定的速率）发送数据，不管接收方是否能处理，也不管网络是否拥堵。</li>
</ul>
</li>
<li><strong>应用场景:</strong><ul>
<li><strong>TCP:</strong> 适用于要求<strong>高可靠性、有序传输</strong>的应用。如网页浏览 (HTTP&#x2F;S)、文件传输 (FTP)、邮件 (SMTP&#x2F;POP3&#x2F;IMAP) 等。</li>
<li><strong>UDP:</strong> 适用于<strong>实时性要求高、能容忍少量丢包</strong>的应用，或者应用层自己实现了可靠性保障。如实时音视频通话 (VoIP)、在线游戏、DNS 查询、直播流、物联网数据上报等。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>特性</th>
<th>TCP (Transmission Control Protocol)</th>
<th>UDP (User Datagram Protocol)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>连接性</strong></td>
<td>面向连接 (Connection-oriented)</td>
<td>无连接 (Connectionless)</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>可靠 (Reliable)</td>
<td>不可靠 (Unreliable &#x2F; Best-effort)</td>
</tr>
<tr>
<td><strong>传输方式</strong></td>
<td>字节流 (Byte Stream)</td>
<td>数据报 (Datagram)</td>
</tr>
<tr>
<td><strong>顺序保证</strong></td>
<td>有序 (Ordered)</td>
<td>无序 (Unordered)</td>
</tr>
<tr>
<td><strong>流量控制</strong></td>
<td>有 (Flow Control)</td>
<td>无</td>
</tr>
<tr>
<td><strong>拥塞控制</strong></td>
<td>有 (Congestion Control)</td>
<td>无</td>
</tr>
<tr>
<td><strong>速度&#x2F;效率</strong></td>
<td>相对慢 &#x2F; 效率低</td>
<td>快 &#x2F; 效率高</td>
</tr>
<tr>
<td><strong>头部开销</strong></td>
<td>较大 (≥ 20 bytes)</td>
<td>小 (8 bytes)</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>Web, Email, File Transfer (可靠性优先)</td>
<td>Streaming, VoIP, DNS, Games (实时性优先)</td>
</tr>
</tbody></table>
<h4 id="你了解防抖和节流吗？它们的区别是什么？"><a href="#你了解防抖和节流吗？它们的区别是什么？" class="headerlink" title="你了解防抖和节流吗？它们的区别是什么？"></a><strong>你了解防抖和节流吗？它们的区别是什么？</strong></h4><p><strong>我：</strong> 是的，我了解防抖 (Debounce) 和节流 (Throttle)。它们都是用来优化高频触发事件（比如 <code>window.resize</code>, <code>scroll</code>, <code>input</code> 输入等）处理函数执行频率的技术，目的是提升性能和避免不必要的计算或请求。</p>
<ul>
<li><strong>防抖 (Debounce):</strong><ul>
<li><strong>策略:</strong> <strong>当事件持续触发时，并不会执行处理函数，只有当事件停止触发后，等待一个指定的时间间隔（delay），如果这个间隔内没有再次触发事件，才会执行一次处理函数。如果在这个间隔内事件又被触发了，则重新计时</strong>。</li>
<li><strong>好比:</strong> 电梯关门。只要有人在持续按开门按钮，电梯门就不会关。只有当最后一个人进来，并且在指定时间内（比如 3 秒）没有人再按开门按钮，电梯门才会关闭。</li>
<li>应用场景:<ul>
<li>搜索框输入建议（用户停止输入后再发请求）。</li>
<li>窗口大小调整后重新计算布局（只在用户调整完毕后计算一次）。</li>
<li>表单验证（用户停止输入后再进行校验）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>节流 (Throttle):</strong><ul>
<li><strong>策略:</strong> 确保一个函数在<strong>指定的时间间隔内最多只执行一次</strong>。无论事件触发多频繁，处理函数都会以固定的频率（如每 200 毫秒）执行一次。</li>
<li><strong>好比:</strong> 游戏技能冷却。按键按得再快，技能也只能在冷却时间结束后才能再次释放。或者像地铁的闸机，固定时间内只能通过一个人。</li>
<li>应用场景:<ul>
<li>页面滚动事件监听，用于判断是否到达某个位置（没必要每次滚动都计算，每隔几百毫秒检查一次即可）。</li>
<li>拖拽操作的实时更新（限制更新频率）。</li>
<li>高频点击按钮防止重复提交（比如限制 1 秒内只能提交一次）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>核心区别:</strong><ul>
<li><strong>防抖</strong>关注的是事件<strong>停止触发</strong>后的那一次执行，它会“取消”之前的等待，重新开始计时。适用于只需要最终结果的场景。</li>
<li><strong>节流</strong>关注的是在<strong>固定时间间隔内</strong>最多执行一次，它保证了函数执行的频率不会过高。适用于需要周期性响应的场景。</li>
</ul>
</li>
</ul>
<h4 id="你知道事件委托吗？能解释一下吗？"><a href="#你知道事件委托吗？能解释一下吗？" class="headerlink" title="你知道事件委托吗？能解释一下吗？"></a><strong>你知道事件委托吗？能解释一下吗？</strong></h4><p><strong>我：</strong> 是的，我知道事件委托 (Event Delegation)。</p>
<ul>
<li><strong>概念:</strong> 它是一种利用<strong>事件冒泡 (Event Bubbling)</strong> 机制，将事件监听器添加到<strong>父元素</strong>上，而不是直接添加到多个子元素上，用来管理一群子元素上发生的同类型事件的技术。</li>
<li><strong>原理:</strong> 当子元素上的事件被触发时，这个事件会沿着 DOM 树向上传播（冒泡）到其祖先元素。我们可以在父元素（或更上层的祖先元素）上设置一个监听器来捕获这个冒泡上来的事件。在父元素的监听函数内部，我们可以通过检查事件对象 <code>event</code> 的 <code>target</code> 属性 (<code>event.target</code>) 来判断事件<strong>实际起源于哪个子元素</strong>。如果这个 <code>target</code> 是我们关心的子元素类型，我们就可以执行相应的处理逻辑。</li>
<li>优点:<ol>
<li><strong>性能提升:</strong> 减少了需要添加到页面上的事件监听器的数量，从而减少了内存占用和 DOM 操作，尤其在子元素非常多的时候效果显著。</li>
<li><strong>动态元素支持:</strong> 对于后续通过 JavaScript 动态添加到父元素中的子元素，无需再单独为它们绑定事件监听器，事件委托的机制会自动处理这些新元素的事件。</li>
<li><strong>代码简化:</strong> 可以将多个子元素的事件处理逻辑集中到父元素的监听器中，使代码更简洁、易于维护。</li>
</ol>
</li>
</ul>
<h4 id="你知道事件的传递流程吗？（冒泡和捕获）"><a href="#你知道事件的传递流程吗？（冒泡和捕获）" class="headerlink" title="你知道事件的传递流程吗？（冒泡和捕获）"></a><strong>你知道事件的传递流程吗？（冒泡和捕获）</strong></h4><p><strong>我：</strong> 是的，我知道 DOM 事件的传递流程，它包含三个阶段：</p>
<ol>
<li><strong>捕获阶段 (Capturing Phase):</strong><ul>
<li>事件从 <code>window</code> 对象开始，沿着 DOM 树<strong>向下传播</strong>，经过目标元素的各个祖先节点，一直到达事件的目标元素 (Target Element)。</li>
<li>在这个阶段，如果在路径上的任何节点注册了<strong>捕获类型</strong>的事件监听器 (<code>addEventListener</code> 的第三个参数 <code>useCapture</code> 设置为 <code>true</code>)，那么这些监听器会被依次触发。</li>
</ul>
</li>
<li><strong>目标阶段 (Target Phase):</strong><ul>
<li>事件到达<strong>目标元素</strong>。</li>
<li>浏览器会触发注册在目标元素自身上的事件监听器。在这个阶段触发的监听器，无论是捕获还是冒泡类型注册的，都会被执行（执行顺序取决于注册顺序等因素，但它们都在目标阶段被调用）。</li>
</ul>
</li>
<li><strong>冒泡阶段 (Bubbling Phase):</strong><ul>
<li>事件从<strong>目标元素</strong>开始，沿着 DOM 树<strong>向上传播</strong>，经过其各个祖先节点，最终回到 <code>window</code> 对象。</li>
<li>在这个阶段，如果在路径上的任何节点注册了<strong>冒泡类型</strong>的事件监听器 (<code>addEventListener</code> 的第三个参数 <code>useCapture</code> 设置为 <code>false</code> 或省略，这是默认行为)，那么这些监听器会被依次触发。</li>
<li><strong>注意:</strong> 不是所有事件都会冒泡，例如 <code>focus</code>, <code>blur</code>, <code>load</code>, <code>unload</code> 等事件默认不冒泡。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>控制流程:</strong><ul>
<li>我们可以使用 <code>event.stopPropagation()</code> 方法在任何阶段阻止事件继续传播（阻止后续的捕获或冒泡）。</li>
<li><code>event.stopImmediatePropagation()</code> 不仅阻止传播，还会阻止<strong>同一元素上</strong>绑定<strong>同一事件类型</strong>的<strong>其他监听器</strong>被执行。</li>
</ul>
</li>
<li><strong>事件委托</strong> 主要利用的就是<strong>冒泡阶段</strong>。</li>
</ul>
<h4 id="CDN是什么"><a href="#CDN是什么" class="headerlink" title="CDN是什么?"></a><strong>CDN是什么?</strong></h4><p><strong>我：</strong> CDN 是 <strong>Content Delivery Network</strong> (内容分发网络) 的缩写。</p>
<ul>
<li><strong>概念:</strong> 它是一个由<strong>地理上分散</strong>的服务器（称为<strong>边缘节点</strong>或 PoP - Point of Presence）组成的网络，这些服务器协同工作，旨在更快、更可靠地将静态或动态 Web 内容（如图片、CSS 文件、JavaScript 文件、视频、HTML 页面等）分发给终端用户。</li>
<li>工作原理:<ol>
<li>网站的原始文件存储在<strong>源服务器 (Origin Server)</strong> 上。</li>
<li>CDN 服务商将这些文件的副本<strong>缓存</strong>到其全球各地的<strong>边缘服务器</strong>上。</li>
<li>当用户尝试访问网站内容时，CDN 的智能路由系统（通常基于 DNS）会将用户的请求导向到离用户<strong>地理位置最近</strong>或<strong>网络延迟最低</strong>的那个<strong>边缘服务器</strong>。</li>
<li>该边缘服务器直接将缓存的内容响应给用户。如果边缘服务器没有缓存该内容或缓存已过期，它会先向源服务器请求最新的内容，缓存后再响应给用户。</li>
</ol>
</li>
<li>主要优点:<ol>
<li><strong>加速网站加载速度:</strong> 用户从更近的服务器获取内容，大大减少了网络延迟 (Latency)。</li>
<li><strong>提高网站可用性和冗余:</strong> 即使某个边缘服务器或源服务器出现故障，请求也可以被路由到其他健康的服务器，减少了单点故障的风险。</li>
<li><strong>降低源服务器负载和带宽成本:</strong> 大部分用户请求由 CDN 边缘服务器处理，减轻了源服务器的压力和带宽消耗。</li>
<li><strong>增强网站的全球可扩展性:</strong> 可以轻松应对全球范围内的用户访问和流量高峰。</li>
<li><strong>提升安全性:</strong> 许多 CDN 提供商还提供额外的安全服务，如 DDoS 攻击缓解、Web 应用防火墙 (WAF) 等。</li>
</ol>
</li>
</ul>

  </div>
  

</article>

<!-- Comments -->

<!-- End Comments --></section>
    <footer id="footer" role="contentinfo">
    <div>&copy; 2025 <a href="/">DayBreak</a>.
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Designed by <a href="http://rainylog.com" target="_blank">Rainy.</a>
	</div>
</footer><!-- end #footer -->

  </div>
  
<script src="/lib/fancybox/dist/jquery.fancybox.min.js"></script>


  
<script src="/js/helper.js"></script>

  
<script src="/js/_third-party/gitment.js"></script>

</body>
</html>