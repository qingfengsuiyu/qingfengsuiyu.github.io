<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>tag: 八股文 | DayBreak</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="坚持与从俗不同信仰的困难">
<meta property="og:type" content="website">
<meta property="og:title" content="DayBreak">
<meta property="og:url" content="https://qingfengsuiyu.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="DayBreak">
<meta property="og:description" content="坚持与从俗不同信仰的困难">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Xiaoyi Hao">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="DayBreak" type="application/atom+xml">
  
  
  
  
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0.css">

  
<link rel="stylesheet" href="/lib/fancybox/dist/jquery.fancybox.min.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<script src="/lib/jquery/dist/jquery.min.js"></script>

  
  
  
  
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="wrapper">
    <header id="header" class="clearfix">
	<a id="logo" href="/" title="DayBreak">DayBreak</a>
	
	<nav id="nav-menu" class="clearfix">
		<form id="search" method="post" action="./" role="search">
			<input id="search-input" type="text" name="s" class="inputbox" value="Search" onfocus="if (value =='Search'){value =''}" onblur="if (value ==''){value='Search'}">
		</form>
		<ul>
      
				
        <li><a class="main-nav-link" href="/">Home</a></li>
      
				
        <li><a class="main-nav-link" href="/archives">Archives</a></li>
      
		</ul>
	</nav>
</header>
    <section id="main" class="clearfix">
  <article class="post-detail">
    <h1 class="post-title"><a href="/">八股积累-03</a></h1>
    <ul class="post-meta">
  <li><i class="fa fa-user"></i> Author Xiaoyi Hao</li>
  <li><i class="fa fa-calendar"></i> Date Apr 18</li>
  <li><i class="fa fa-folder"></i> Categories
  
    no_categories
  
  </li>
</ul>
    <div class="post-content">
      <p><strong>1. 根节点的font-size设置了一个不好计算的值，不能修改。之后写em的时候不方便怎么解决？</strong></p>
<p>面试官您好，这是一个实践中可能遇到的问题。如果根节点（<code>html</code>）的 <code>font-size</code> 是一个不方便计算的值（比如 <code>13.8px</code>），并且我们不能修改它，那么直接使用 <code>em</code> 单位确实会比较困难，因为 <code>em</code> 是相对于父元素的 <code>font-size</code> 计算的，层级嵌套深了之后，计算会变得非常复杂和不直观。</p>
<p>面对这种情况，我推荐使用 <strong><code>rem</code> (root em) 单位</strong>。</p>
<ul>
<li><strong>原因：</strong> <code>rem</code> 单位始终是相对于根元素（<code>html</code>）的 <code>font-size</code> 来计算的，无论元素嵌套多深。即使根元素的 <code>font-size</code> 是 <code>13.8px</code>，那么 <code>1rem</code> 就固定等于 <code>13.8px</code>，<code>2rem</code> 就等于 <code>27.6px</code>。</li>
<li><strong>优势：</strong><ul>
<li><strong>计算清晰：</strong> 所有使用 <code>rem</code> 的元素的尺寸都只与根元素的 <code>font-size</code> 相关，避免了 <code>em</code> 单位层层继承带来的计算复杂性。</li>
<li><strong>全局缩放：</strong> 虽然我们不能修改初始的 <code>font-size</code>，但如果未来有需求要进行全局字体或布局缩放（例如通过媒体查询调整根 <code>font-size</code>），所有使用 <code>rem</code> 的元素都会等比例缩放，维护起来更方便。</li>
</ul>
</li>
</ul>
<p><strong>2. 宏任务和微任务了解吗？</strong></p>
<p>是的，面试官，我了解宏任务（Macrotask）和微任务（Microtask）。它们是 JavaScript 异步执行模型——事件循环（Event Loop）中的重要概念。</p>
<ul>
<li><strong>事件循环 (Event Loop):</strong> JavaScript 是单线程的，为了处理异步操作（如定时器、网络请求、DOM事件等）而不会阻塞主线程，引入了事件循环机制。它不断检查调用栈（Call Stack）是否为空，如果为空，就去任务队列（Task Queue）中取任务来执行。</li>
<li><strong>宏任务 (Macrotask):</strong><ul>
<li>代表一个独立的、比较大的工作单元。</li>
<li>每次事件循环只会从宏任务队列中取出一个宏任务来执行。</li>
<li>执行完一个宏任务后，可能会进行页面的重新渲染（Rendering），然后才开始下一次事件循环Tick。</li>
<li>常见的宏任务包括：<ul>
<li><code>script</code> (整体代码块)</li>
<li><code>setTimeout</code>, <code>setInterval</code></li>
<li><code>setImmediate</code> (Node.js 环境)</li>
<li>I&#x2F;O 操作（文件读写、网络请求等的回调）</li>
<li>UI 渲染（浏览器环境）</li>
<li>用户交互事件（如 click, mousemove 等的回调）</li>
</ul>
</li>
</ul>
</li>
<li><strong>微任务 (Microtask):</strong><ul>
<li>代表一个需要在当前任务执行后立即执行的小任务，通常用于处理当前任务的后续工作，比如 Promise 的状态敲定。</li>
<li>微任务队列拥有更高的优先级。当一个宏任务执行完毕后，<strong>在下一个宏任务开始之前（并且通常在 UI 渲染之前）</strong>，事件循环会检查微任务队列。如果微任务队列不为空，它会<strong>一次性执行完所有</strong>的微任务，直到微任务队列清空。如果在执行微任务的过程中又产生了新的微任务，这些新的微任务也会被添加到队列末尾并在当前轮次被执行。</li>
<li>常见的微任务包括：<ul>
<li><code>Promise.then()</code>, <code>Promise.catch()</code>, <code>Promise.finally()</code> 的回调</li>
<li><code>MutationObserver</code> 的回调</li>
<li><code>queueMicrotask()</code></li>
<li><code>process.nextTick</code> (Node.js 环境，优先级甚至高于其他微任务)</li>
</ul>
</li>
</ul>
</li>
<li><strong>执行顺序总结：</strong><ol>
<li>执行同步代码（一个宏任务）。</li>
<li>执行过程中遇到的同步代码立即执行。</li>
<li>遇到的宏任务放入宏任务队列。</li>
<li>遇到的微任务放入微任务队列。</li>
<li>当前宏任务执行完毕，检查微任务队列。</li>
<li>执行并清空微任务队列（过程中新产生的微任务也在此轮执行）。</li>
<li>（可能进行 UI 渲染 - 浏览器决定）</li>
<li>从宏任务队列中取下一个宏任务，重复步骤 2-7。</li>
</ol>
</li>
</ul>
<p><strong>5. 反向输出数字，例如 123 输出 321（把数字转换成字符串做，面试官说只用数字来做，就求余取整）</strong></p>
<p><strong>思路：</strong></p>
<p>核心思想是利用取余运算符 (<code>%</code>) 获取数字的最后一位，然后利用整除（在 JavaScript 中是 <code>Math.floor(number / 10)</code>）去掉数字的最后一位。我们不断重复这个过程，同时构建反转后的数字。</p>
<p><strong>算法步骤：</strong></p>
<ol>
<li>初始化一个变量 <code>reversedNumber</code> 为 0，用来存放反转后的结果。</li>
<li>使用一个循环，条件是原数字 <code>originalNumber</code> 不为 0（或者大于 0，如果只处理正数）。</li>
<li>在循环内部： a.  通过 <code>originalNumber % 10</code> 得到 <code>originalNumber</code> 的最后一位数字 (<code>digit</code>)。 b.  将 <code>reversedNumber</code> 乘以 10（相当于将其所有位数向左移动一位，为新来的个位数腾出位置），然后加上刚刚得到的 <code>digit</code>。更新 <code>reversedNumber = reversedNumber * 10 + digit;</code>。 c.  通过 <code>Math.floor(originalNumber / 10)</code> (或者在某些语言中直接用整数除法) 去掉 <code>originalNumber</code> 的最后一位，更新 <code>originalNumber</code>。</li>
<li>循环结束后，<code>reversedNumber</code> 就包含了反转后的数字。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverseInteger</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> reversedNumber = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> sign = num &lt; <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>; <span class="comment">// 处理负数的情况</span></span><br><span class="line">  <span class="keyword">let</span> absoluteNum = <span class="title class_">Math</span>.<span class="title function_">abs</span>(num); <span class="comment">// 先处理绝对值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (absoluteNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> digit = absoluteNum % <span class="number">10</span>; <span class="comment">// 取最后一位</span></span><br><span class="line">    reversedNumber = reversedNumber * <span class="number">10</span> + digit; <span class="comment">// 追加到结果的末尾</span></span><br><span class="line">    absoluteNum = <span class="title class_">Math</span>.<span class="title function_">floor</span>(absoluteNum / <span class="number">10</span>); <span class="comment">// 去掉最后一位</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reversedNumber * sign; <span class="comment">// 恢复符号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reverseInteger</span>(<span class="number">123</span>));    <span class="comment">// 输出: 321</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reverseInteger</span>(-<span class="number">456</span>));   <span class="comment">// 输出: -654</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reverseInteger</span>(<span class="number">120</span>));    <span class="comment">// 输出: 21 (前导零会自然消失)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reverseInteger</span>(<span class="number">0</span>));      <span class="comment">// 输出: 0</span></span><br></pre></td></tr></table></figure>

<p><strong>6.什么是跨域？</strong></p>
<p>跨域是指浏览器限制脚本（JavaScript）发起跨源 HTTP 请求的一种安全策略。所谓“跨源”，指的是请求的目标 URL 与当前页面所在的 URL 的<strong>协议 (protocol)、域名 (domain)、端口 (port)</strong> 三者之中有任意一个不同。例如，<code>http://example.com</code> 访问 <code>https://example.com</code>（协议不同）、<code>http://www.example.com</code> 访问 <code>http://api.example.com</code>（域名不同）、<code>http://example.com:80</code> 访问 <code>http://example.com:8080</code>（端口不同），这些都属于跨域。</p>
<p><strong>为什么会有跨域限制（同源策略 Same-Origin Policy, SOP）？</strong></p>
<p>同源策略是浏览器最核心、最基本的安全功能。它的主要目的是<strong>防止恶意网站读取或篡改另一个源的文档数据和用户会话信息</strong>。如果没有同源策略，一个恶意网站（比如 <code>http://evil.com</code>）就可以轻易地用 JavaScript 向你的网上银行（比如 <code>https://mybank.com</code>）发送请求，并在用户不知情的情况下执行操作（比如转账），或者读取你登录银行后的敏感信息。同源策略限制了这种潜在的攻击，保护了用户数据的安全性和网站的完整性。</p>
<p><strong>常见的解决跨域问题的方案：</strong></p>
<ol>
<li><strong>CORS (Cross-Origin Resource Sharing, 跨源资源共享):</strong><ul>
<li>这是目前<strong>最主流、最标准</strong>的解决方案。它允许服务器通过设置特定的 HTTP 响应头（如 <code>Access-Control-Allow-Origin</code>, <code>Access-Control-Allow-Methods</code>, <code>Access-Control-Allow-Headers</code> 等）来声明哪些源、哪些方法、哪些头部是被允许访问其资源的。</li>
<li>浏览器在检测到跨域请求时，会先发送一个“预检”请求（OPTIONS 方法，针对非简单请求），询问服务器是否允许该跨域请求。服务器响应允许后，浏览器才会发送实际的请求。</li>
<li>优点：功能强大、灵活、安全，支持各种 HTTP 方法和自定义头部。</li>
<li>缺点：需要服务器端配合进行配置。</li>
</ul>
</li>
<li><strong>JSONP (JSON with Padding):</strong><ul>
<li>这是一种比较古老的、利用 <code>&lt;script&gt;</code> 标签不受同源策略限制的“hack”方案。</li>
<li>原理：前端动态创建一个 <code>&lt;script&gt;</code> 标签，其 <code>src</code> 指向后端提供的接口 URL，并在 URL 参数中带上一个回调函数名（如 <code>callback=handleResponse</code>）。服务器接收到请求后，不再返回纯 JSON 数据，而是返回一段 JavaScript 代码，这段代码会调用前端指定的回调函数，并将 JSON 数据作为参数传入 (<code>handleResponse(&#123;...data...&#125;);</code>)。</li>
<li>优点：兼容性好（老浏览器也支持），简单易用。</li>
<li>缺点：<ul>
<li><strong>只支持 GET 请求</strong>。</li>
<li><strong>安全性较低</strong>，容易遭受 XSS 攻击，因为服务器返回的是可执行代码。</li>
<li>请求失败时（如网络错误）不易捕获和处理。</li>
</ul>
</li>
<li>现在已逐渐被 CORS 取代。</li>
</ul>
</li>
<li><strong>代理 (Proxy):</strong><ul>
<li>通过在<strong>同源</strong>的服务器上设置一个代理接口，由这个代理接口去请求目标跨域服务器的资源，然后再将结果返回给前端。前端与代理服务器之间是同源的，代理服务器与目标服务器之间（服务器间请求）不受浏览器同源策略限制。</li>
<li><strong>正向代理:</strong> 代理客户端，前端配置代理服务器访问外部资源。（不太用于解决前端跨域问题，更多用于网络访问控制）</li>
<li><strong>反向代理 (Nginx, Apache等):</strong> 代理服务器端。前端请求同源的 Nginx 服务器上的某个路径，Nginx 内部配置将该请求转发到实际的跨域 API 服务器，并将响应返回给前端。这是开发和部署中非常常用的方式。</li>
<li>优点：前端无需修改代码（像访问同源接口一样），安全性较好，可以集成缓存、负载均衡等功能。</li>
<li>缺点：需要额外部署和配置代理服务器。</li>
</ul>
</li>
<li><strong><code>postMessage</code> API:</strong><ul>
<li>主要用于<strong>窗口之间</strong>（如 <code>iframe</code> 与父窗口、<code>window.open</code> 打开的窗口与源窗口）的安全跨源通信。</li>
<li>一个窗口可以通过 <code>otherWindow.postMessage(message, targetOrigin)</code> 向另一个窗口发送消息，接收方通过监听 <code>message</code> 事件 (<code>window.addEventListener(&#39;message&#39;, receiveMessage);</code>) 来接收。发送时可以指定 <code>targetOrigin</code>，确保消息只发送给预期的源，接收方也可以验证 <code>event.origin</code> 来确保消息来源可信。</li>
<li>优点：安全、标准，专门用于窗口间通信。</li>
<li>缺点：仅适用于窗口间通信场景。</li>
</ul>
</li>
<li><strong>WebSocket:</strong><ul>
<li>WebSocket 协议本身<strong>不受同源策略限制</strong>，因为它不是 HTTP 协议。一旦 WebSocket 连接建立，客户端和服务器就可以双向、实时地传输数据，不受域名、协议、端口的影响。</li>
<li>服务器端可以在握手阶段验证请求的来源 (<code>Origin</code> 头部)。</li>
<li>优点：实现双向实时通信，不受跨域限制。</li>
<li>缺点：需要服务器端支持 WebSocket 协议，适用于实时性要求高的场景。</li>
</ul>
</li>
</ol>
<p>选择哪种方案取决于具体的应用场景、技术栈以及对安全性和兼容性的要求。目前 CORS 和反向代理是最常用和推荐的方式。</p>
<p><strong>7.你提到了正向代理和反向代理。请明确区分一下这两者，它们分别解决了什么问题？</strong></p>
<p><strong>我:</strong> 好的，面试官。正向代理和反向代理是两种不同的代理模式，它们代理的对象和解决的问题是不同的。您的笔记中提到的“都是正向代理”是不准确的，而后面的定义“正向代理：代理的是客户端，隐藏客户端，反向代理：代理的是服务器，隐藏服务器”是正确的。</p>
<p><strong>1. 正向代理 (Forward Proxy):</strong></p>
<ul>
<li><strong>代理对象:</strong> 客户端 (Client)。它工作在客户端和目标服务器 (Origin Server) 之间。</li>
<li><strong>工作方式:</strong> 客户端（比如用户的浏览器）明确配置了代理服务器的地址。所有出站的网络请求都先发送给正向代理服务器，由代理服务器<strong>代替客户端</strong>去访问目标服务器，并将获取到的响应返回给客户端。</li>
<li>特点:<ul>
<li><strong>隐藏客户端:</strong> 对于目标服务器来说，它看到的是代理服务器的 IP 地址，而不是实际客户端的 IP 地址。</li>
<li><strong>客户端知情:</strong> 客户端需要知道代理服务器的存在并进行配置。</li>
</ul>
</li>
<li>解决的问题&#x2F;用途:<ul>
<li><strong>访问控制&#x2F;防火墙:</strong> 公司或组织内部可以通过正向代理限制员工访问特定网站。</li>
<li><strong>绕过访问限制:</strong> 用户可以通过位于不同地理位置或网络环境的正向代理来访问被本地网络限制的资源（俗称“科学上网”）。</li>
<li><strong>缓存:</strong> 代理服务器可以缓存目标服务器的响应，加速对相同资源的访问。</li>
<li><strong>日志记录&#x2F;审计:</strong> 记录客户端的网络访问行为。</li>
</ul>
</li>
</ul>
<p><strong>2. 反向代理 (Reverse Proxy):</strong></p>
<ul>
<li><strong>代理对象:</strong> 服务器 (Server)。它工作在客户端和源服务器集群之间。</li>
<li><strong>工作方式:</strong> 客户端直接访问的是反向代理服务器的地址（通常是公开的域名），客户端<strong>并不知道</strong>实际处理请求的后端服务器是哪台。反向代理服务器接收到请求后，根据一定的规则（如 URL 路径、负载均衡策略等）将请求<strong>转发给内部网络中的一个或多个源服务器</strong>进行处理，并将源服务器的响应返回给客户端。</li>
<li>特点:<ul>
<li><strong>隐藏服务器:</strong> 对于客户端来说，它只与反向代理服务器交互，不知道后端真实服务器的 IP 地址、数量和架构。</li>
<li><strong>客户端不知情:</strong> 客户端认为它直接访问的就是目标服务。</li>
</ul>
</li>
<li>解决的问题&#x2F;用途:<ul>
<li><strong>负载均衡 (Load Balancing):</strong> 将请求分发到多个后端服务器，提高服务的并发处理能力和可用性。</li>
<li><strong>安全防护:</strong> 作为应用防火墙 (WAF)，抵御常见的网络攻击（如 DDoS、SQL注入），隐藏后端服务器细节。</li>
<li><strong>SSL 加密&#x2F;解密 (SSL Offloading):</strong> 统一处理 HTTPS 请求的加密解密，减轻后端服务器的负担。</li>
<li><strong>缓存静态内容:</strong> 缓存后端服务器的响应，减少对后端服务器的请求压力，加快响应速度。</li>
<li><strong>请求路由&#x2F;API 网关:</strong> 根据请求路径或其他条件将请求转发到不同的后端服务或微服务。</li>
<li><strong>解决跨域问题:</strong> 如前面提到的，可以将前端部署在域名 A，API 服务器部署在域名 B，通过在域名 A 上设置反向代理，将 <code>/api</code> 路径的请求转发到域名 B，对前端来说就像是同源请求。</li>
</ul>
</li>
</ul>
<p><strong>总结:</strong></p>
<ul>
<li><strong>正向代理</strong>是“替”客户端去访问服务器，隐藏了客户端。</li>
<li><strong>反向代理</strong>是“替”服务器来接收客户端的请求，隐藏了服务器。</li>
</ul>
<p>它们在网络架构中扮演不同的角色，解决不同的问题。在 Web 开发中，我们常使用 Nginx、Apache 等作为反向代理来实现负载均衡、安全防护和解决跨域等问题。</p>
<p><strong>8.总结一下 TypeScript 相较于 JavaScript 的主要区别和优点吗？</strong></p>
<p><strong>我:</strong> 当然可以。TypeScript (TS) 是 JavaScript (JS) 的一个<strong>超集 (Superset)</strong>，它在 JavaScript 的基础上增加了<strong>静态类型系统</strong>和其他一些特性。它们的主要区别和 TS 的优点可以总结如下：</p>
<p><strong>主要区别:</strong></p>
<ol>
<li><p><strong>类型系统:</strong></p>
<ul>
<li><strong>JS:</strong> 动态类型。变量的类型在运行时确定，可以在运行时改变。类型错误（如将字符串当数字用）只有在代码执行到那一行时才会被发现。</li>
<li><strong>TS:</strong> 静态类型。可以在编码阶段为变量、函数参数、返回值等显式指定类型。类型检查在<strong>编译阶段</strong>进行。虽然 TS 代码最终会编译成 JS，但在开发过程中就能发现类型错误。</li>
</ul>
</li>
<li><p><strong>编译:</strong></p>
<ul>
<li><strong>JS:</strong> 通常直接在浏览器或 Node.js 环境中解释执行（虽然现代 JS 引擎也有 JIT 编译，但这里指的是开发者通常的工作流）。</li>
<li><strong>TS:</strong> <strong>必须</strong>先通过 TypeScript 编译器 (<code>tsc</code>) 编译成 JavaScript 代码，然后才能在浏览器或 Node.js 环境中运行。</li>
</ul>
</li>
<li><p><strong>语言特性:</strong></p>
<ul>
<li><p><strong>TS 包含 JS:</strong> 所有有效的 JavaScript 代码也是有效的 TypeScript 代码。</p>
</li>
<li><p>TS 扩展 JS:</p>
<p>TS 增加了许多 JS 没有（或尚未正式标准化）的特性，主要围绕类型系统：</p>
<ul>
<li><strong>类型注解 (Type Annotations):</strong> 如 <code>let name: string;</code></li>
<li><strong>接口 (Interfaces):</strong> 定义对象的结构契约。</li>
<li><strong>类型别名 (Type Aliases):</strong> 使用 <code>type</code> 关键字创建自定义类型。</li>
<li><strong>枚举 (Enums):</strong> 定义一组命名的常量。</li>
<li><strong>泛型 (Generics):</strong> 编写可重用的、支持多种类型的代码。</li>
<li><strong>元组 (Tuples):</strong> 定义固定长度和固定类型顺序的数组。</li>
<li><strong>联合类型 (Union Types) &#x2F; 交叉类型 (Intersection Types):</strong> 组合多种类型。</li>
<li><strong>访问修饰符 (Access Modifiers):</strong> 如 <code>public</code>, <code>private</code>, <code>protected</code> 用于类成员（编译时检查）。</li>
<li><strong>可选类型 (?) &#x2F; 只读属性 (readonly):</strong> 更精确地定义属性。</li>
<li><strong>非空断言 (!):</strong> 告诉编译器某个值不会是 <code>null</code> 或 <code>undefined</code>。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>TypeScript 的主要优点:</strong></p>
<ol>
<li><strong>静态类型检查，错误早期发现:</strong> 这是 TS 最核心的优势。能够在<strong>编译阶段</strong>就捕获大量的类型相关错误（如拼写错误、类型不匹配、<code>null</code> 或 <code>undefined</code> 引用等），而不是等到运行时才暴露。这大大减少了线上 Bug，缩短了调试时间。</li>
<li>代码可读性和可维护性增强:<ul>
<li>类型注解本身就是一种<strong>代码即文档</strong>，清晰地表明了数据结构和函数契约，使得代码更容易理解。</li>
<li>在大型项目或团队协作中，类型系统提供了强约束，有助于保持代码风格一致，降低维护成本。</li>
<li>重构代码（如修改函数签名、重命名属性）时更加安全可靠，编译器会帮助检查所有受影响的地方。</li>
</ul>
</li>
<li>更好的开发体验和工具支持:<ul>
<li>强大的 <strong>IDE 支持</strong>（如 VS Code）：基于类型信息，IDE 可以提供更精确的自动补全、智能提示 (IntelliSense)、代码导航和自动重构功能。</li>
<li>这极大地提高了开发效率和编码体验。</li>
</ul>
</li>
<li>更好的代码组织和架构:<ul>
<li>接口、泛型、模块等特性有助于设计出更健壮、更可复用的代码结构。</li>
<li>使得构建大型复杂应用更加得心应手。</li>
</ul>
</li>
<li><strong>与 JavaScript 生态兼容:</strong> TS 完全兼容 JS，可以逐步引入现有 JS 项目，并能无缝使用庞大的 NPM 生态中的 JS 库（通过类型声明文件 <code>@types</code> 或库自带的类型）。</li>
<li><strong>支持最新的 JavaScript 特性:</strong> TS 团队通常会较早地支持 ECMAScript 的新特性，并允许开发者将这些新特性编译到旧版本的 JS，兼顾了新语法的使用和向后兼容。</li>
</ol>
<p><strong>缺点（相对而言）:</strong></p>
<ul>
<li><strong>学习曲线:</strong> 需要学习额外的类型语法和概念。</li>
<li><strong>编译步骤:</strong> 需要额外的编译环节。</li>
<li><strong>代码量增加:</strong> 需要编写类型注解，代码会稍微冗长一些（但带来的好处通常远超这点）。</li>
<li><strong>类型体操:</strong> 复杂的类型推导和定义有时会比较棘手（俗称“类型体操”）。</li>
</ul>
<p>总的来说，TypeScript 通过引入静态类型系统，极大地提升了 JavaScript 开发的健壮性、可维护性和开发效率，尤其适用于大型、复杂的项目和团队协作。</p>
<p><strong>8.算法题：如何找到一个无序数组中第 K 大的数？</strong></p>
<p><strong>基于快速排序思想 (快速选择算法 Quick Select)</strong></p>
<ul>
<li><p>思路:</p>
<p>这是快速排序算法的一个变种。<strong>快速排序的核心是 partition(分区)</strong></p>
<p>操作：选择一个基准值 (pivot)，将数组分区为两部分——小于 pivot 的元素和大于等于 pivot 的元素，并返回 pivot 的最终位置索引 p。</p>
<ol>
<li>在数组中随机选择一个 pivot。</li>
<li>执行 <code>partition</code> 操作，将数组分为 <code>[小于 pivot 的元素]</code>, <code>pivot</code>, <code>[大于等于 pivot 的元素]</code> 三部分。得到 pivot 在排序后数组中的最终索引 <code>p</code>。</li>
<li>我们想找的是第 K 大的元素，它在排序后数组中的索引应该是 <code>N - K</code>（假设数组长度为 N，索引从 0 开始）。</li>
<li>比较 p和 N - K：<ul>
<li>如果 <code>p == N - K</code>，那么 pivot 就是我们要找的第 K 大的数，直接返回 <code>array[p]</code>。</li>
<li>如果 <code>p &lt; N - K</code>，说明第 K 大的数在 pivot 的<strong>右边</strong>（更大的那部分），我们需要在右子数组 <code>[p+1, end]</code> 中继续查找第 <code>K</code> 大的数（注意：相对 K 值不变，因为我们是从大往小找 K 个）。</li>
<li>如果 <code>p &gt; N - K</code>，说明第 K 大的数在 pivot 的<strong>左边</strong>（较小的那部分），我们需要在左子数组 <code>[start, p-1]</code> 中继续查找第 <code>K</code> 大的数。</li>
</ul>
</li>
<li>递归地在选定的子数组中重复步骤 1-4，直到找到目标索引。</li>
</ol>
</li>
</ul>
<p><strong>9.Vue 的依赖收集机制</strong></p>
<p>Vue 的依赖收集是响应式系统的核心机制，它负责追踪组件依赖的数据变化并在数据变化时更新视图。我来解释这个过程：</p>
<p><strong>基本原理</strong></p>
<p>Vue 的响应式系统主要基于两个核心概念：</p>
<ol>
<li><strong>Observer(客观观察或旁观)</strong>：将普通 JavaScript 对象转换为响应式对象</li>
<li><strong>Watcher(持续关注、监视或守护)</strong>：负责监听数据变化并执行更新函数</li>
</ol>
<p><strong>依赖收集过程</strong></p>
<p>当一个组件渲染时，会读取数据属性，这时 Vue 就会进行依赖收集：</p>
<ol>
<li>数据初始化时通过 <code>Object.defineProperty</code>（Vue 2）或 <code>Proxy</code>（Vue 3）将数据转换为响应式对象</li>
<li>每个响应式属性都有一个对应的 <strong>Dep</strong> 对象（依赖收集器）</li>
<li>组件渲染时，创建一个 <strong>Watcher</strong> 实例</li>
<li>在读取数据时，将当前的 Watcher 设置为”正在计算的 Watcher”</li>
<li>数据被读取时，将当前 Watcher 添加到该数据的 Dep 收集器中</li>
<li>当数据变化时，Dep 通知所有收集的 Watcher 进行更新</li>
</ol>
<p>假设我们有一个简单的 Vue 组件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &quot;Hello Vue&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>依赖收集过程如下：</p>
<ol>
<li>Vue 创建组件实例时，将 data 中的 message 属性转换为响应式对象：<ul>
<li>对 <code>message</code> 使用 <code>Object.defineProperty</code>（Vue 2）或 <code>Proxy</code>（Vue 3）</li>
<li>创建一个 Dep 实例与 <code>message</code> 关联</li>
</ul>
</li>
<li>当组件渲染模板时：<ul>
<li>创建一个渲染 Watcher</li>
<li>执行渲染函数，这会读取 <code>message</code> 的值</li>
<li>在读取 <code>message</code> 时，当前的渲染 Watcher 被设置为”正在计算的 Watcher”</li>
<li><code>message</code> 的 getter 方法被调用，它会执行 <code>dep.depend()</code>，将当前 Watcher 添加到 <code>message</code> 的依赖列表</li>
</ul>
</li>
<li>当 message 变化时：<ul>
<li>触发 <code>message</code> 的 setter 方法</li>
<li>setter 调用 <code>dep.notify()</code>，通知所有依赖此数据的 Watcher</li>
<li>渲染 Watcher 收到通知，重新执行渲染函数，更新 DOM</li>
</ul>
</li>
</ol>
<p><strong>写一道关于事件循环（Event Loop）的题目，并解释输出结果和原因。</strong></p>
<p><strong>我:</strong> 好的，这是一道考察宏任务（Macrotask）和微任务（Microtask）执行顺序的典型题目：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>); <span class="comment">// 5</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>); <span class="comment">// 3</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>); <span class="comment">// 4</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请问以上代码的输出顺序是什么？</span></span><br></pre></td></tr></table></figure>

<p><strong>输出结果:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>

<p><strong>解释原因:</strong></p>
<ol>
<li><strong>同步代码执行:</strong> 首先执行全局上下文中的同步代码。<ul>
<li><code>console.log(&#39;script start&#39;);</code> 被执行，输出 ‘script start’。</li>
<li>遇到 <code>setTimeout</code>，它是一个 Web API（宏任务源）。它的回调函数会被注册到 Web API 中，并在指定时间（这里是0ms后，但实际上会有一个最小延迟，且必须等待主线程空闲）后放入<strong>宏任务队列</strong>（Task Queue）。</li>
<li>遇到 <code>Promise.resolve().then(...)</code>。<code>Promise.resolve()</code> 会立即创建一个状态为 resolved 的 Promise。<code>.then()</code> 中的回调函数会被注册到<strong>微任务队列</strong>（Microtask Queue）。接着，第二个 <code>.then()</code> 也会被注册到微任务队列，排在第一个后面。</li>
<li><code>console.log(&#39;script end&#39;);</code> 被执行，输出 ‘script end’。</li>
</ul>
</li>
<li><strong>同步代码执行完毕，检查微任务队列:</strong> 此时，全局同步代码执行完成，调用栈（Call Stack）变空。根据事件循环机制，在进入下一个宏任务之前，必须清空当前的微任务队列。<ul>
<li>从微任务队列中取出第一个任务（<code>promise1</code> 的回调），推入调用栈执行，输出 ‘promise1’。</li>
<li>微任务队列中还有第二个任务（<code>promise2</code> 的回调），继续取出，推入调用栈执行，输出 ‘promise2’。</li>
<li>此时微任务队列已空。</li>
</ul>
</li>
<li><strong>执行宏任务:</strong> 微任务队列清空后，事件循环会检查宏任务队列。<ul>
<li>发现 <code>setTimeout</code> 的回调函数已经在宏任务队列中。</li>
<li>取出 <code>setTimeout</code> 的回调函数，推入调用栈执行，输出 ‘setTimeout’。</li>
</ul>
</li>
<li><strong>结束:</strong> 调用栈再次变空，微任务队列为空，宏任务队列也为空（在此例中）。事件循环继续等待新的任务。</li>
</ol>
<p><strong>总结:</strong> 事件循环的核心在于区分宏任务和微任务。同步代码最先执行，然后执行所有当前轮次的微任务，最后才从宏任务队列中取出一个宏任务执行。这个过程不断重复。</p>
<p><strong>回调地狱（Callback Hell）有什么常见的解法？</strong></p>
<p><strong>我:</strong> 回调地狱（Callback Hell），也叫“毁灭金字塔（Pyramid of Doom）”，通常发生在需要处理多个相互依赖的异步操作时，后一个操作依赖于前一个操作的结果，导致回调函数层层嵌套，代码形态像一个向右倾斜的金字塔。这使得代码难以阅读、理解、调试和维护。</p>
<p>常见的解法主要有以下几种：</p>
<ol>
<li><p><strong>Promises (ES6 标准，推荐):</strong></p>
<ul>
<li><p><strong>核心思想:</strong> Promise 对象代表一个异步操作的最终完成（或失败）及其结果值。它允许你将回调函数（通过 <code>.then()</code> 和 <code>.catch()</code>）附加到异步操作上，而不是直接将回调传递给异步函数。</p>
</li>
<li><p><strong>链式调用 (<code>.then()</code>):</strong> <code>then</code> 方法返回一个新的 Promise，可以继续链接下一个 <code>.then()</code>，处理下一个异步操作。这使得原本嵌套的结构变成了扁平的、线性的链式结构。</p>
</li>
<li><p><strong>错误处理 (<code>.catch()</code>):</strong> 提供统一的错误捕获机制。链中任何地方发生的错误（无论是同步抛出还是 Promise 被 reject）都可以被链末尾的 <code>.catch()</code> 捕获。</p>
</li>
<li><p><strong>并行处理 (<code>Promise.all</code>, <code>Promise.race</code>, <code>Promise.allSettled</code>):</strong> 提供了处理多个并发异步操作的工具方法。</p>
</li>
<li><p>示例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">asyncOperation1</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">result1</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">asyncOperation2</span>(result1); <span class="comment">// 返回一个新的 Promise</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">result2</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">asyncOperation3</span>(result2);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">result3</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Final result:&#x27;</span>, result3);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;An error occurred:&#x27;</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Async&#x2F;Await (ES2017 标准，基于 Promises，强烈推荐):</strong> * <strong>核心思想:</strong> <code>async/await</code> 是建立在 Promises 之上的语法糖。它允许你用看起来像同步代码的方式来编写异步代码。 * <strong><code>async</code> 函数:</strong> 函数声明前加上 <code>async</code> 关键字，表明该函数内部可能包含异步操作，并且该函数总是隐式地返回一个 Promise。 * <strong><code>await</code> 操作符:</strong> 只能在 <code>async</code> 函数内部使用。它会暂停 <code>async</code> 函数的执行，等待其后的 Promise 完成（resolve 或 reject）。如果 Promise resolve，<code>await</code> 会返回 resolve 的值；如果 Promise reject，<code>await</code> 会抛出错误（就像同步代码中的 <code>throw</code>）。 * <strong>错误处理 (<code>try...catch</code>):</strong> 可以使用标准的 <code>try...catch</code> 语句来捕获 <code>await</code> 操作可能抛出的错误，使得异步错误处理和同步错误处理方式统一。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">processAsyncTask</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟异步操作</span></span><br><span class="line">    <span class="keyword">const</span> result1 = <span class="keyword">await</span> <span class="title function_">asyncOperation1</span>(); <span class="comment">// 假设这是一个异步操作</span></span><br><span class="line">    <span class="keyword">const</span> result2 = <span class="keyword">await</span> <span class="title function_">asyncOperation2</span>(result1); <span class="comment">// 假设这是一个异步操作，接受一个参数</span></span><br><span class="line">    <span class="keyword">const</span> result3 = <span class="keyword">await</span> <span class="title function_">asyncOperation3</span>(result2); <span class="comment">// 假设这是一个异步操作，接受两个参数</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Final result:&#x27;</span>, result3); <span class="comment">// 输出最终结果</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;An error occurred:&#x27;</span>, error); <span class="comment">// 输出错误信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">processAsyncTask</span>(); <span class="comment">// 输出最终结果</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>总结:</strong> 目前解决回调地狱最主流、最推荐的方法是使用 <strong>Promises</strong>，尤其是结合 <strong>Async&#x2F;Await</strong> 语法，它们能极大地提升异步代码的可读性、可维护性和健壮性。</p>
<p>React Fiber 是 React 16 引入的一种新的协调（reconciliation）引擎，它的核心目标是提高 React 应用的性能，尤其是在处理复杂的 UI 更新时。Fiber 的一个重要特性是它的链表结构，这种结构使得 React 能够更好地管理和调度渲染任务。</p>
<h3 id="React-Fiber-的链表结构"><a href="#React-Fiber-的链表结构" class="headerlink" title="React Fiber 的链表结构"></a>React Fiber 的链表结构</h3><p>在 React Fiber 中，UI 组件树被表示为一个 Fiber 树，每个组件对应一个 Fiber 节点。这些 Fiber 节点通过链表的形式连接在一起，形成了一种树形结构，但与传统的 DOM 树不同，Fiber 树更像是一个带有指针的链表结构。</p>
<p>具体来说，Fiber 节点之间通过以下几种指针相互连接：</p>
<ol>
<li><strong>child 指针</strong>：指向当前节点的第一个子节点。</li>
<li><strong>sibling 指针</strong>：指向当前节点的下一个兄弟节点。</li>
<li><strong>return 指针</strong>：指向当前节点的父节点（在 Fiber 中称为“return”，而不是“parent”，因为它表示任务返回的方向）。</li>
</ol>
<p>这种链表结构的设计有以下几个优势：</p>
<ul>
<li><strong>增量渲染</strong>：React Fiber 可以将渲染工作拆分成多个小任务，逐个处理 Fiber 节点。这样可以在浏览器空闲时执行任务，避免长时间阻塞主线程，从而提升用户体验（例如避免卡顿）。</li>
<li><strong>优先级调度</strong>：通过链表结构，React 可以轻松地暂停和恢复渲染任务，优先处理高优先级的更新（比如用户输入），再处理低优先级的任务。</li>
<li><strong>错误处理和副作用管理</strong>：链表结构使得 React 能够更好地追踪和管理组件的生命周期和副作用（比如 useEffect）。</li>
</ul>
<h3 id="Fiber-树的工作原理"><a href="#Fiber-树的工作原理" class="headerlink" title="Fiber 树的工作原理"></a>Fiber 树的工作原理</h3><p>React 在运行时会维护两棵 Fiber 树：</p>
<ol>
<li><strong>当前树（current tree）</strong>：表示当前屏幕上显示的内容。</li>
<li><strong>工作树（work-in-progress tree）</strong>：表示正在进行更新的内容。</li>
</ol>
<p>当有更新发生时，React 会基于当前树构建一个新的工作树，计算出需要更新的节点（diff 过程），然后将更新应用到 DOM 上，最后将工作树变成新的当前树。这种双树结构结合链表的设计，使得 React 能够高效地处理更新。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>React Fiber 的链表结构是其实现增量渲染和优先级调度的基础。通过 child、sibling 和 return 指针，Fiber 节点形成了一个灵活且易于遍历的树形结构。这种设计让 React 能够在复杂的 UI 更新中保持高效和响应性。</p>

    </div>
  </article>

  <article class="post-detail">
    <h1 class="post-title"><a href="/">八股积累-02</a></h1>
    <ul class="post-meta">
  <li><i class="fa fa-user"></i> Author Xiaoyi Hao</li>
  <li><i class="fa fa-calendar"></i> Date Apr 15</li>
  <li><i class="fa fa-folder"></i> Categories
  
    no_categories
  
  </li>
</ul>
    <div class="post-content">
      <p><strong>1、HTTP缓存</strong></p>
<p>HTTP缓存是一种优化技术，浏览器或中间缓存服务器（如CDN）将请求过的Web资源（如HTML页面、图片、CSS、JS文件）存储起来。当用户再次请求相同资源时，可以直接从本地缓存或邻近的缓存服务器中获取，而无需向源服务器发送请求。这大大减少了请求延迟，节省了网络带宽，降低了服务器负载，提升了用户体验。</p>
<p>HTTP缓存主要分为两大类：</p>
<ul>
<li><strong>强制缓存 (Strong Cache):</strong><ul>
<li>浏览器直接检查本地缓存的有效性，无需向服务器发送请求。</li>
</ul>
</li>
<li><strong>协商缓存 (Negotiation Cache &#x2F; Conditional Cache):</strong><ul>
<li>强制缓存失效后（或者<code>Cache-Control: no-cache</code>），浏览器会向服务器发送一个条件请求。</li>
<li>服务器根据请求中的条件判断资源是否有更新。</li>
<li>如果服务器判断资源未改变，返回 <code>304 Not Modified</code>，浏览器便可安全地使用本地缓存。</li>
</ul>
</li>
</ul>
<p><strong>缓存流程:</strong> 浏览器请求资源 -&gt; 检查强制缓存 (Cache-Control&#x2F;Expires) -&gt; 若命中且有效，直接使用 (200 from cache) -&gt; 若强制缓存无效或不存在 -&gt; 发起HTTP请求，带上协商缓存头 (If-Modified-Since&#x2F;If-None-Match) -&gt; 服务器检查协商缓存头 -&gt; 若资源未改变，返回304，浏览器使用本地缓存 -&gt; 若资源已改变，返回200和新资源，浏览器更新缓存。</p>
<p><strong>2、跨域</strong></p>
<p>跨域是指浏览器出于安全原因，限制网页脚本访问不同源 (Origin) 的资源。<strong>源</strong>由<strong>协议 (Protocol)</strong>、<strong>域名 (Domain&#x2F;Host)</strong> 和 <strong>端口 (Port)</strong> 三者共同定义。只要这三者中有一个不同，就构成跨域。</p>
<p>这是浏览器的<strong>同源策略 (Same-Origin Policy, SOP)</strong> 导致的，它是一个重要的安全基石，旨在防止恶意网站读取或篡改其他网站的敏感数据。</p>
<p>常见的跨域场景包括：</p>
<ul>
<li>AJAX 请求访问不同源的 API。</li>
<li>页面中的 <code>&lt;iframe&gt;</code> 加载不同源的页面，并试图通过脚本进行交互。</li>
<li>Web 字体、Canvas&#x2F;WebGL 绘制使用了不同源的图片等。</li>
</ul>
<p><strong>3、前端缓存有哪几种</strong></p>
<p>前端缓存是指将数据或资源存储在客户端（浏览器）的技术，以提高应用性能和用户体验。主要有以下几种：</p>
<ol>
<li><strong>HTTP 缓存:</strong> (前面已详细说明) 浏览器根据 HTTP 响应头自动处理的资源缓存（强缓存、协商缓存）。这是最基础也是应用最广泛的缓存。</li>
<li><strong>LocalStorage:</strong> HTML5 Web Storage API 提供的<strong>持久化本地存储方案</strong>。以<strong>键值对（Key-Value）形式</strong>存储<strong>字符串</strong>数据。<strong>除非用户手动清除浏览器数据或代码主动删除，否则数据会一直存在</strong>，即使关闭浏览器或标签页也不会消失。容量通常为 5-10MB。<strong>同源限制</strong>。</li>
<li><strong>SessionStorage:</strong> 与 LocalStorage 类似，也是键值对存储字符串。但它的生命周期与<strong>浏览器会话</strong>绑定，即<strong>当标签页或浏览器窗口关闭后，SessionStorage 中存储的数据会被清除</strong>。容量和同源限制同 LocalStorage。适合存储临时性的会话数据。</li>
<li><strong>IndexedDB:</strong> 一个在浏览器中运行的、功能强大的<strong>事务型</strong>数据库系统。允许存储大量的结构化数据（包括文件&#x2F;Blob），并支持索引以实现高性能查询。API 是<strong>异步</strong>的。比 LocalStorage&#x2F;SessionStorage 复杂，但提供了更强大的数据管理能力。同源限制。</li>
<li><strong>Cookies:</strong> 小段文本信息，由服务器通过 <code>Set-Cookie</code> 响应头发送给浏览器，浏览器将其存储，并在后续对<strong>同一服务器</strong>的<strong>每次</strong>请求中通过 <code>Cookie</code> 请求头自动带上。**主要用于用户身份认证、会话管理、跟踪用户行为等。缺点是容量小（约 4KB），且每次请求都会携带，可能造成带宽浪费。**可以通过设置 <code>HttpOnly</code> 防止脚本访问，提高安全性。</li>
</ol>
<p><strong>4、防抖和节流如何实现</strong></p>
<p>防抖 (Debounce) 和节流 (Throttle) 是两种优化高频触发事件（如 <code>resize</code>, <code>scroll</code>, <code>input</code> 等）的常用技术，它们都通过<strong>返回一个新函数</strong>来实现。</p>
<ul>
<li><p><strong>防抖 (Debounce) 实现:</strong></p>
<ul>
<li><strong>目标:</strong> 在事件触发后，等待一段指定的延迟时间。如果在这段延迟时间内没有新的事件触发，则执行目标函数；如果延迟时间内又有新的事件触发，则<strong>重新计时</strong>。简而言之：<strong>只在最后一次触发后的指定延迟后执行一次</strong>。</li>
<li><strong>实现思路:</strong> 使用 <code>setTimeout</code> 来管理延迟执行。每次事件触发时，先清除之前的定时器，然后设置一个新的定时器。</li>
</ul>
<p>JavaScript</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; func 要执行的目标函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; delay 延迟时间 (ms)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Function</span>&#125; 包装后的防抖函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeoutId = <span class="literal">null</span>; <span class="comment">// 定时器 ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个新函数，这个函数将作为事件处理程序</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 保存 this 上下文和参数</span></span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已有定时器，则清除它（取消之前的延迟执行）</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置一个新的定时器</span></span><br><span class="line">    timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 延迟时间到了，执行目标函数</span></span><br><span class="line">      <span class="comment">// 使用 apply 来保持正确的 this 指向和传递参数</span></span><br><span class="line">      func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">      timeoutId = <span class="literal">null</span>; <span class="comment">// 执行完毕，重置 timeoutId (可选)</span></span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 使用示例 ---</span></span><br><span class="line"><span class="comment">// const debouncedHandler = debounce(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&#x27;窗口大小已停止变化一段时间&#x27;);</span></span><br><span class="line"><span class="comment">// &#125;, 500);</span></span><br><span class="line"><span class="comment">// window.addEventListener(&#x27;resize&#x27;, debouncedHandler);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>节流 (Throttle) 实现:</strong></p>
<ul>
<li><strong>目标:</strong> 在指定的<strong>时间间隔内，最多只执行一次</strong>目标函数。无论事件触发多频繁，都会以固定的频率执行。简而言之：<strong>固定时间内只执行一次，多余的触发忽略</strong>。</li>
<li><strong>实现思路 (基于定时器):</strong> 使用一个标志位（或检查定时器是否存在）来判断是否可以执行。如果可以执行，则立即执行（或设置定时器执行），然后设置一个定时器，在时间间隔结束后才允许下一次执行。</li>
</ul>
<p>JavaScript</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数 (基于定时器，首次触发可能延迟)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; func 要执行的目标函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; interval 时间间隔 (ms)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Function</span>&#125; 包装后的节流函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeoutId = <span class="literal">null</span>; <span class="comment">// 定时器 ID</span></span><br><span class="line">  <span class="keyword">let</span> lastArgs = <span class="literal">null</span>; <span class="comment">// 保存最后一次的参数</span></span><br><span class="line">  <span class="keyword">let</span> lastThis = <span class="literal">null</span>; <span class="comment">// 保存最后一次的 this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个新函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    lastArgs = args; <span class="comment">// 保存参数</span></span><br><span class="line">    lastThis = <span class="variable language_">this</span>; <span class="comment">// 保存 this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果定时器不存在，表示可以设置新的执行</span></span><br><span class="line">    <span class="keyword">if</span> (!timeoutId) &#123;</span><br><span class="line">      timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 时间间隔到了，执行函数</span></span><br><span class="line">        func.<span class="title function_">apply</span>(lastThis, lastArgs);</span><br><span class="line">        <span class="comment">// 清除定时器，允许下一次设置</span></span><br><span class="line">        timeoutId = <span class="literal">null</span>;</span><br><span class="line">        lastArgs = <span class="literal">null</span>;</span><br><span class="line">        lastThis = <span class="literal">null</span>;</span><br><span class="line">      &#125;, interval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果定时器已存在，则忽略本次触发（或者也可以选择在定时器结束后执行最后一次触发的调用）</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 使用示例 (另一种常见实现：首次立即执行，之后节流) ---</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttleImmediate</span>(<span class="params">func, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span>; <span class="comment">// 标志位，表示是否可以立即执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) &#123;</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 如果不能运行，则忽略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    canRun = <span class="literal">false</span>; <span class="comment">// 标记为不能立即运行</span></span><br><span class="line">    <span class="comment">// 立即执行一次</span></span><br><span class="line">    func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器，在 interval 毫秒后恢复 canRun</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, interval);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// const throttledHandler = throttleImmediate(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&#x27;滚动事件被节流处理&#x27;);</span></span><br><span class="line"><span class="comment">// &#125;, 200);</span></span><br><span class="line"><span class="comment">// window.addEventListener(&#x27;scroll&#x27;, throttledHandler);</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>5、代码题， 大数相加</strong></p>
<p>当两个数字非常大，超过了 JavaScript 的 <code>Number.MAX_SAFE_INTEGER</code> (2^53 - 1)，直接使用 <code>+</code> 运算符会丢失精度。这时需要将数字作为字符串处理，模拟手动加法的过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大数相加</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; num1 第一个大数（字符串形式）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; num2 第二个大数（字符串形式）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">string</span>&#125; 两个大数相加的结果（字符串形式）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addBigIntegers</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = num1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 指向 num1 末尾</span></span><br><span class="line">  <span class="keyword">let</span> j = num2.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 指向 num2 末尾</span></span><br><span class="line">  <span class="keyword">let</span> carry = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 结果字符串</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从个位开始，只要还有数字位或者有进位，就继续循环</span></span><br><span class="line">  <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取当前位的数字，如果索引&lt;0，则视为 0</span></span><br><span class="line">    <span class="keyword">const</span> digit1 = i &gt;= <span class="number">0</span> ? <span class="built_in">parseInt</span>(num1[i]) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> digit2 = j &gt;= <span class="number">0</span> ? <span class="built_in">parseInt</span>(num2[j]) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前位的和（加上进位）</span></span><br><span class="line">    <span class="keyword">const</span> sum = digit1 + digit2 + carry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前位的结果是 sum % 10</span></span><br><span class="line">    <span class="keyword">const</span> currentDigit = sum % <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 新的进位是 Math.floor(sum / 10)</span></span><br><span class="line">    carry = <span class="title class_">Math</span>.<span class="title function_">floor</span>(sum / <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前位的结果拼接到结果字符串的前面</span></span><br><span class="line">    result = currentDigit + result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动索引</span></span><br><span class="line">    i--;</span><br><span class="line">    j--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果结果是 &#x27;0&#x27;，并且输入不是 &#x27;0&#x27; + &#x27;0&#x27;，确保返回 &#x27;0&#x27; 而不是空串（虽然此逻辑下不会是空串）</span></span><br><span class="line">  <span class="comment">// 此处可以简化，因为循环条件保证了至少处理一次</span></span><br><span class="line">  <span class="comment">// if (result === &#x27;&#x27; &amp;&amp; (num1 !== &#x27;0&#x27; || num2 !== &#x27;0&#x27;)) return &#x27;0&#x27;; // 防御性代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 示例测试 ---</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addBigIntegers</span>(<span class="string">&quot;123&quot;</span>, <span class="string">&quot;456&quot;</span>)); <span class="comment">// 输出: &quot;579&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addBigIntegers</span>(<span class="string">&quot;99&quot;</span>, <span class="string">&quot;1&quot;</span>));    <span class="comment">// 输出: &quot;100&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addBigIntegers</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;999&quot;</span>));   <span class="comment">// 输出: &quot;1000&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addBigIntegers</span>(<span class="string">&quot;12345678901234567890&quot;</span>, <span class="string">&quot;98765432109876543210&quot;</span>)); <span class="comment">// 输出: &quot;111111111001111111100&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addBigIntegers</span>(<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>));     <span class="comment">// 输出: &quot;0&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>实现思路:</strong></p>
<ol>
<li>初始化两个指针 <code>i</code> 和 <code>j</code> 分别指向两个数字字符串的末尾，进位 <code>carry</code> 为 0，结果字符串 <code>result</code> 为空。</li>
<li>使用 <code>while</code> 循环，条件是 <code>i</code> 或 <code>j</code> 没有越界（还没处理完所有位），或者 <code>carry</code> 大于 0（最高位有进位）。</li>
<li>在循环内部：<ul>
<li>获取 <code>num1[i]</code> 和 <code>num2[j]</code> 对应的数字。如果索引已经小于 0，则该位视为 0。使用 <code>parseInt()</code> 转换字符为数字。</li>
<li>计算 <code>sum = digit1 + digit2 + carry</code>。</li>
<li>当前位的值是 <code>sum % 10</code>。</li>
<li>新的进位是 <code>Math.floor(sum / 10)</code>。</li>
<li>将当前位的值（<code>sum % 10</code>）<strong>拼接</strong>到 <code>result</code> 字符串的<strong>前面</strong>。</li>
<li>将 <code>i</code> 和 <code>j</code> 向前移动（<code>i--</code>, <code>j--</code>）。</li>
</ul>
</li>
<li>循环结束后，<code>result</code> 就是最终的、正确顺序的和。</li>
</ol>
<h4 id="缓存策略应用："><a href="#缓存策略应用：" class="headerlink" title="缓存策略应用："></a><strong>缓存策略应用：</strong></h4><ul>
<li><strong>不常变化的静态资源（CSS, JS, 图片, 字体）：</strong> 设置很长的<code>max-age</code>（例如一年 <code>max-age=31536000</code>），并配合<strong>内容哈希或版本号</strong>的文件名（如 <code>style.a1b2c3d4.css</code> 或 <code>main.v1.js</code>）。当文件内容更新时，文件名改变，浏览器会请求新资源；文件名不变时，则长期利用缓存。</li>
<li><strong>可能会变化的资源（HTML，某些API数据）：</strong> 使用 <code>no-cache</code> 或 <code>max-age=0</code>，强制每次使用前进行验证（发送<code>If-Modified-Since</code>或<code>If-None-Match</code>请求）。如果资源未变，服务器返回<code>304</code>，只传输少量头部信息，仍然比重新下载整个资源快。</li>
<li><strong>敏感数据或频繁变化的API数据：</strong> 使用<code>no-store</code>，完全禁止缓存。</li>
</ul>
<h4 id="那么请你详细描述一下-从在浏览器地址栏输入一个URL-到最终页面渲染出来的整个过程"><a href="#那么请你详细描述一下-从在浏览器地址栏输入一个URL-到最终页面渲染出来的整个过程" class="headerlink" title="那么请你详细描述一下,从在浏览器地址栏输入一个URL.到最终页面渲染出来的整个过程."></a>那么请你详细描述一下,从在浏览器地址栏输入一个URL.到最终页面渲染出来的整个过程.</h4><ol>
<li><p><strong>用户输入与URL解析:</strong></p>
<ul>
<li>用户在浏览器地址栏输入URL（例如 <code>https://www.example.com/path?query=value#fragment</code>）。</li>
<li>浏览器首先解析这个URL，识别出协议 (<code>https</code>)、域名 (<code>www.example.com</code>)、端口（HTTPS默认为443）、路径 (<code>/path</code>)、查询参数 (<code>?query=value</code>) 和片段标识符 (<code>#fragment</code>)。</li>
<li>如果输入的是搜索词而非URL，浏览器会使用默认搜索引擎将其转换为搜索结果页面的URL。</li>
</ul>
</li>
<li><p><strong>检查缓存:</strong></p>
<ul>
<li><p>浏览器缓存:</p>
<p>浏览器首先检查其本地缓存（内存缓存、磁盘缓存）。它会根据URL和缓存策略（</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires</span><br></pre></td></tr></table></figure>

<p>）判断是否存在有效（未过期）的资源副本。</p>
<ul>
<li><strong>强缓存命中:</strong> 如果找到未过期的有效副本（在<code>max-age</code>内），浏览器直接从缓存读取资源，不发起网络请求。这是最快的情况（可能看到 <code>200 OK (from memory cache)</code> 或 <code>200 OK (from disk cache)</code>）。整个过程可能在这里就结束了HTML文档的获取。</li>
<li><strong>协商缓存:</strong> 如果资源已过期或被标记为<code>no-cache</code>，浏览器需要向服务器验证资源是否更新。它会准备发起网络请求，并在请求头中带上缓存标识（如<code>If-Modified-Since</code>或<code>If-None-Match</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>DNS域名解析:</strong></p>
<ul>
<li><p>如果缓存未命中或需要验证，浏览器需要知道目标服务器的IP地址。</p>
</li>
<li><p><strong>查找本地缓存:</strong> 浏览器先检查自身DNS缓存 -&gt; 操作系统<code>hosts</code>文件 -&gt; 操作系统DNS缓存。</p>
</li>
<li><p><strong>路由器缓存:</strong> 如果本地没有，查询路由器的DNS缓存。</p>
</li>
<li><p><strong>ISP DNS服务器:</strong> 查询本地ISP（互联网服务提供商）提供的DNS服务器。</p>
</li>
<li><p>根域名服务器查询 (递归过程):</p>
<p>如果ISP DNS服务器也没有缓存，它会发起递归查询：</p>
<ul>
<li>ISP DNS问 <strong>根域名服务器</strong>: “.com” 域名的顶级域（TLD）服务器地址是什么？</li>
<li>根服务器返回 <strong>TLD服务器</strong> 地址。</li>
<li>ISP DNS问 <strong>TLD服务器</strong>: “example.com” 的权威名称服务器（Authoritative Name Server）地址是什么？</li>
<li>TLD服务器返回 <strong>权威名称服务器</strong> 地址。</li>
<li>ISP DNS问 <strong>权威名称服务器</strong>: “<a target="_blank" rel="noopener" href="https://www.example.com/">www.example.com</a>“ 的IP地址是什么？</li>
<li>权威名称服务器返回最终的IP地址。</li>
</ul>
</li>
<li><p><strong>结果缓存:</strong> ISP DNS服务器缓存这个结果（遵循TTL），并返回给操作系统，操作系统再返回给浏览器。</p>
</li>
</ul>
</li>
<li><p><strong>建立TCP连接:</strong></p>
<ul>
<li>浏览器获得IP地址和端口号（HTTP默认80，HTTPS默认443）后，会尝试与服务器建立TCP连接。</li>
<li>这通过三次握手 (Three-way Handshake)完成：<ol>
<li><strong>SYN:</strong> 浏览器发送一个SYN（同步）包到服务器，请求建立连接。</li>
<li><strong>SYN-ACK:</strong> 服务器收到SYN后，如果同意连接，会回复一个SYN-ACK（同步确认）包。</li>
<li><strong>ACK:</strong> 浏览器收到SYN-ACK后，发送一个ACK（确认）包给服务器。连接建立成功。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>TLS&#x2F;SSL握手 (如果是HTTPS):</strong></p>
<ul>
<li>如果URL是HTTPS协议，在TCP连接建立后，还需要进行TLS&#x2F;SSL握手以建立安全信道：<ol>
<li><strong>Client Hello:</strong> 浏览器发送支持的加密套件、TLS版本、一个随机数等信息。</li>
<li><strong>Server Hello:</strong> 服务器选择一个加密套件、TLS版本，返回自己的数字证书和一个随机数。</li>
<li><strong>Certificate Verification:</strong> 浏览器验证服务器证书的有效性（是否由信任的CA签发、是否过期、域名是否匹配）。</li>
<li><strong>Key Exchange:</strong> 浏览器生成另一个随机数（预主密钥），用服务器证书中的公钥加密后发送给服务器。</li>
<li><strong>Session Keys Generated:</strong> 双方根据三个随机数和协商的算法，生成对称的会话密钥，用于后续通信加密。</li>
<li><strong>Finished:</strong> 双方互相发送加密的“Finished”消息，确认握手完成。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>发送HTTP(S)请求:</strong></p>
<ul>
<li>TCP（和TLS）连接建立后，浏览器构造并发送一个HTTP请求报文。</li>
<li>报文包含：请求行（方法GET&#x2F;POST等，路径，HTTP版本）、请求头（<code>Host</code>, <code>User-Agent</code>, <code>Accept</code>, <code>Cookie</code>, <code>Referer</code>, 以及前面提到的缓存验证头<code>If-Modified-Since</code>&#x2F;<code>If-None-Match</code>等）、以及可选的请求体（POST请求的数据）。</li>
</ul>
</li>
<li><p><strong>服务器处理请求并响应:</strong></p>
<ul>
<li>服务器（如Nginx, Apache）接收到请求。</li>
<li>Web服务器可能将请求转交给应用服务器（如Node.js, Tomcat, PHP）。</li>
<li>后端代码执行，可能查询数据库、处理业务逻辑。</li>
<li>服务器生成一个HTTP响应报文。</li>
<li>报文包含：状态行（HTTP版本，状态码如 <code>200 OK</code>, <code>304 Not Modified</code>, <code>404 Not Found</code>等）、响应头（<code>Content-Type</code>, <code>Content-Length</code>, <code>Set-Cookie</code>, 以及缓存控制头<code>Cache-Control</code>, <code>ETag</code>, <code>Last-Modified</code>等）、以及响应体（通常是HTML内容，但也可能是CSS, JS, 图片等）。</li>
</ul>
</li>
<li><p><strong>浏览器接收并处理响应:</strong></p>
<ul>
<li>浏览器接收HTTP响应。</li>
<li><strong>检查状态码:</strong> 如果是<code>304 Not Modified</code>，浏览器直接从缓存加载资源。如果是<code>200 OK</code>等成功状态码，则处理响应体。如果是重定向（3xx），浏览器会根据<code>Location</code>头发出新的请求。如果是错误（4xx, 5xx），可能会显示错误页面。</li>
<li>处理响应体 (以HTML为例):<ul>
<li>浏览器根据响应头中的<code>Content-Type</code>（例如 <code>text/html</code>）来决定如何处理响应体。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>渲染页面:</strong> 这是浏览器内部非常复杂的过程，大致分为：</p>
<ul>
<li><strong>解析HTML (Parsing HTML):</strong> 浏览器将接收到的HTML文本解析成<strong>DOM (Document Object Model)</strong> 树。这是一个基于节点的对象表示，反映了HTML的结构。HTML解析器是<strong>渐进式</strong>的，边接收边解析。</li>
<li><strong>解析CSS (Parsing CSS):</strong> 在解析HTML时，如果遇到<code>&lt;link&gt;</code>标签引入外部CSS文件，或<code>&lt;style&gt;</code>标签内的CSS，浏览器会异步请求并解析CSS，构建<strong>CSSOM (CSS Object Model)</strong> 树。CSSOM表示了所有元素的样式信息。</li>
<li><strong>构建渲染树 (Render Tree Construction):</strong> 浏览器将DOM树和CSSOM树结合起来，生成<strong>渲染树 (Render Tree)</strong>。渲染树只包含<strong>需要显示</strong>的节点（例如<code>display: none</code>的节点会被排除）以及它们的计算后样式。</li>
<li><strong>布局 (Layout &#x2F; Reflow):</strong> 浏览器根据渲染树和视口（viewport）大小，计算每个节点在屏幕上的<strong>确切位置和尺寸</strong>。这个过程称为布局或回流（Reflow）。布局是一个<strong>全局</strong>过程，一个节点的改变可能影响其他节点。</li>
<li><strong>绘制 (Painting &#x2F; Repaint):</strong> 浏览器根据渲染树和布局信息，将每个节点绘制成屏幕上的<strong>实际像素</strong>。绘制通常发生在多个图层（Layers）上。这个过程称为绘制或重绘（Repaint）。</li>
<li><strong>合成 (Compositing):</strong> 浏览器将绘制好的各个图层按照正确的顺序（考虑<code>z-index</code>等）合并、显示在屏幕上。对于有特定属性（如<code>transform</code>, <code>opacity</code>）的元素，浏览器可能会将其提升到单独的合成层（Compositor Layer），由GPU加速处理，这样它们的变换就不会触发整个页面的重绘或回流，性能更好。</li>
</ul>
</li>
<li><p><strong>JavaScript执行:</strong></p>
<ul>
<li>在HTML解析过程中，如果遇到<code>&lt;script&gt;</code>标签（没有<code>async</code>或<code>defer</code>属性），HTML解析会<strong>暂停</strong>，浏览器会请求（如果是外部脚本）、解析并执行JavaScript代码。</li>
<li>JavaScript代码可以<strong>修改DOM和CSSOM</strong>（例如 <code>document.getElementById().style.color = &#39;red&#39;</code> 或 <code>document.createElement()</code>)。这些修改可能会<strong>触发新的回流和重绘</strong>。</li>
<li><code>defer</code>属性会让脚本在HTML解析完成后、<code>DOMContentLoaded</code>事件触发前按顺序执行。</li>
<li><code>async</code>属性会让脚本异步下载并在下载完成后立即执行，不保证顺序，且可能在HTML解析未完成时执行。它们都不阻塞HTML解析。</li>
</ul>
</li>
<li><p><strong>页面加载完成:</strong></p>
<ul>
<li>当所有资源（HTML, CSS, JS, 图片等）加载完成，并且所有<code>defer</code>脚本执行完毕后，浏览器会触发<code>window</code>的<code>load</code>事件。此时，页面完全渲染完成。</li>
</ul>
</li>
</ol>
<h4 id="HTTP-vs-HTTPS-的区别："><a href="#HTTP-vs-HTTPS-的区别：" class="headerlink" title="HTTP vs. HTTPS 的区别："></a><strong>HTTP vs. HTTPS 的区别：</strong></h4><p>主要区别在于<strong>安全性</strong>：</p>
<ol>
<li><p>安全性:</p>
<ul>
<li><p><strong>HTTP (HyperText Transfer Protocol):</strong> 是<strong>明文传输</strong>协议。数据在网络上传输时不加密，容易被中间人窃听、篡改。</p>
</li>
<li><p>HTTPS (HyperText Transfer Protocol Secure):是在HTTP的基础上加入了SSL&#x2F;TLS加密层的安全协议。它提供了：</p>
<ul>
<li><strong>数据加密 (Confidentiality):</strong> 通信内容被加密，第三方无法直接读取。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><strong>数据完整性 (Integrity):</strong> 通过校验机制确保数据在传输过程中未被篡改。<ul>
<li><strong>身份认证 (Authentication):</strong> 通过服务器证书验证网站的真实身份，防止钓鱼网站。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>端口号:</p>
<ul>
<li>HTTP默认使用<strong>80</strong>端口。</li>
<li>HTTPS默认使用<strong>443</strong>端口。</li>
</ul>
</li>
<li><p>连接过程:</p>
<ul>
<li>HTTPS在建立TCP连接后，需要进行额外的<strong>TLS&#x2F;SSL握手</strong>过程来协商加密密钥和验证服务器身份。HTTP则不需要。</li>
</ul>
</li>
<li><p>证书:</p>
<ul>
<li>HTTPS需要向**证书颁发机构（CA）**申请数字证书来证明服务器身份。HTTP不需要。</li>
</ul>
</li>
<li><p>性能:</p>
<ul>
<li>理论上，HTTPS由于涉及加解密和握手过程，会比HTTP稍微慢一点，并消耗更多的服务器资源。但现代CPU对加解密优化得很好，并且可以通过HTTP&#x2F;2等协议优化，这种性能差异通常不显著，安全性带来的好处远大于这点开销。</li>
</ul>
</li>
</ol>
<h4 id="请你说说实现元素水平居中和垂直居中的常用方法有哪些？"><a href="#请你说说实现元素水平居中和垂直居中的常用方法有哪些？" class="headerlink" title="请你说说实现元素水平居中和垂直居中的常用方法有哪些？"></a><strong>请你说说实现元素水平居中和垂直居中的常用方法有哪些？</strong></h4><p><strong>1. Flexbox (弹性布局 - 最常用、最推荐)</strong></p>
<ul>
<li><p><strong>适用场景:</strong> 对块级或行内块级子元素进行居中，无论是否知道子元素尺寸。</p>
</li>
<li><p>方法:在父容器上设置：CSS</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/* 水平居中 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: center;    <span class="comment">/* 垂直居中 */</span></span><br><span class="line">  <span class="comment">/* 可能需要设置父容器高度，例如: min-height: 100vh; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点:</strong> 代码简洁、语义化、功能强大，兼容性好。</p>
</li>
</ul>
<p><strong>2. Grid (网格布局 - 功能强大)</strong></p>
<ul>
<li><p><strong>适用场景:</strong> 类似于Flexbox，特别适合更复杂的二维布局，居中只是其能力之一。</p>
<p>使用 <code>justify-content</code> 和 <code>align-content</code> - 针对网格本身在容器中的对齐:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/* 水平居中网格项(如果只有一个)或整个网格 */</span></span><br><span class="line">  <span class="attribute">align-content</span>: center;   <span class="comment">/* 垂直居中网格项(如果只有一个)或整个网格 */</span></span><br><span class="line">  <span class="comment">/* 可能需要设置父容器高度 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点:</strong> 非常强大，尤其适合二维布局，代码同样简洁。</p>
</li>
</ul>

    </div>
  </article>

  <article class="post-detail">
    <h1 class="post-title"><a href="/">八股积累-01</a></h1>
    <ul class="post-meta">
  <li><i class="fa fa-user"></i> Author Xiaoyi Hao</li>
  <li><i class="fa fa-calendar"></i> Date Apr 13</li>
  <li><i class="fa fa-folder"></i> Categories
  
    no_categories
  
  </li>
</ul>
    <div class="post-content">
      <h4 id="八股积累01"><a href="#八股积累01" class="headerlink" title="八股积累01:"></a><strong>八股积累01:</strong></h4><h5 id="1-script标签的async和defer属性"><a href="#1-script标签的async和defer属性" class="headerlink" title="1.script标签的async和defer属性"></a><strong>1.script标签的async和defer属性</strong></h5><p>“script标签的async和defer属性都用于<strong>优化JavaScript加载执行过程</strong>，但它们的行为有明显区别：</p>
<ul>
<li><strong>defer</strong>：脚本会并行下载，<strong>但会等到HTML解析完成后</strong>，DOMContentLoaded事件前执行，<strong>保持脚本的执行顺序</strong></li>
<li><strong>async</strong>：脚本会并行下载，下载完成后立即执行，<strong>不保证执行顺序</strong>，<strong>也不等待HTML解析完成</strong></li>
</ul>
<p>实际应用中，defer适合那些需要访问完整DOM或有依赖关系的脚本，async更适合独立的第三方脚本，如分析工具等。”</p>
<h5 id="2-同步和异步操作"><a href="#2-同步和异步操作" class="headerlink" title="2.同步和异步操作"></a><strong>2.同步和异步操作</strong></h5><p><strong>在JavaScript中，同步操作按顺序执行，每个操作完成后才执行下一个，这可能导致长时间操作阻塞界面。而异步操作允许代码继续执行而不等待操作完成，结果通过回调函数、Promise或async&#x2F;await处理。</strong></p>
<p><strong>常见的异步操作包括：AJAX请求、setTimeout&#x2F;setInterval、事件监听和文件操作等。</strong></p>
<h5 id="3-对于DOM的操作方法"><a href="#3-对于DOM的操作方法" class="headerlink" title="3.对于DOM的操作方法"></a><strong>3.对于DOM的操作方法</strong></h5><ul>
<li>元素选择：getElementById、querySelector、querySelector<strong>All</strong>等</li>
<li>元素创建：create<strong>Element</strong>、createTextNode</li>
<li>元素修改：appendChild、removeChild、replaceChild、insertBefore</li>
<li>属性操作：<strong>get</strong>Attribute、setAttribute、<strong>remove</strong>Attribute</li>
<li>样式操作：element.style或classList.add&#x2F;remove&#x2F;toggle</li>
<li>内容操作：innerHTML、textContent、innerText</li>
</ul>
<h5 id="4-块级元素和行内元素"><a href="#4-块级元素和行内元素" class="headerlink" title="4.块级元素和行内元素"></a><strong>4.块级元素和行内元素</strong></h5><p><strong>块级元素特点：</strong></p>
<ul>
<li><strong>独占一行，默认宽度为父容器的100%</strong></li>
<li><strong>可以设置width、height、margin和padding</strong></li>
<li><strong>典型的块级元素有：div、p、h1-h6、ul、ol、li、table、form等</strong></li>
</ul>
<p><strong>行内元素特点：</strong></p>
<ul>
<li><strong>不会独占一行，多个行内元素会在同一行显示</strong></li>
<li><strong>宽高由内容决定，设置width和height无效</strong></li>
<li>margin和padding只在水平方向有效</li>
<li><strong>代表元素：span、a、strong、em、img、input等</strong></li>
</ul>
<h5 id="5-盒模型"><a href="#5-盒模型" class="headerlink" title="5.盒模型"></a><strong>5.盒模型</strong></h5><p><strong>标准盒模型(content-box)<strong>和</strong>IE盒模型(border-box)<strong>是CSS中</strong>两种不同的盒模型</strong>。</p>
<p>**标准盒模型下，元素的宽高仅包括内容区(content)，不包括padding、border和margin。**即：</p>
<ul>
<li>实际宽度 &#x3D; width + padding-left + padding-right + border-left + border-right</li>
<li>实际高度 &#x3D; height + padding-top + padding-bottom + border-top + border-bottom</li>
</ul>
<p>**而IE盒模型(border-box)中，元素的宽高包括内容区、padding和border，但不包括margin。**即：</p>
<ul>
<li>width &#x3D; 内容宽度 + padding-left + padding-right + border-left + border-right</li>
<li>height &#x3D; 内容高度 + padding-top + padding-bottom + border-top + border-bottom</li>
</ul>
<h5 id="6-行内元素可以设置宽高吗？怎么设置"><a href="#6-行内元素可以设置宽高吗？怎么设置" class="headerlink" title="6.行内元素可以设置宽高吗？怎么设置"></a><strong>6.行内元素可以设置宽高吗？怎么设置</strong></h5><p><strong>行内元素(inline)默认情况下不能设置宽高，其尺寸由内容决定</strong>。但有两种方式可以让行内元素接受宽高设置：</p>
<p><strong>1.将行内元素转换为块级或行内块元素：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block; <span class="comment">/* 或 inline-block */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.将行内元素设置为flex项目：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际开发中，我更倾向于使用<code>display: inline-block</code>，因为它既可以设置宽高，又不会破坏元素的行内特性，不会强制换行。</p>
<h5 id="7-讲讲position"><a href="#7-讲讲position" class="headerlink" title="7.讲讲position"></a><strong>7.讲讲position</strong></h5><p>CSS的position属性定义元素的定位方式，主要有五个值：</p>
<ol>
<li><code>static</code>(默认值)：元素按照正常文档流进行布局，<strong>top、right、bottom、left和z-index属性无效</strong>。</li>
<li><code>relative</code>：<strong>元素相对于其正常位置进行定位，不脱离文档流，不影响其他元素的布局。</strong></li>
<li><code>absolute</code>：<strong>元素脱离文档流，相对于最近的非static定位祖先元素进行定位。如果没有这样的祖先元素，则相对于初始包含块(通常是viewport)。</strong></li>
<li><code>fixed</code>：<strong>元素脱离文档流，相对于浏览器视口(viewport)进行定位，即使页面滚动也保持固定位置</strong>。</li>
<li><code>sticky</code>：<strong>元素在滚动到特定位置前相当于relative，之后表现为fixed。是relative和fixed的混合</strong>。</li>
</ol>
<h5 id="8-元素水平居中的方式"><a href="#8-元素水平居中的方式" class="headerlink" title="8.元素水平居中的方式"></a><strong>8.元素水平居中的方式</strong></h5><p><strong>对于行内元素或行内块元素：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于固定宽度的块级元素</strong>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用flexbox：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用grid：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">justify-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-讲讲flex"><a href="#9-讲讲flex" class="headerlink" title="9.讲讲flex"></a><strong>9.讲讲flex</strong></h5><p>Flexbox(弹性盒子)是CSS3中的一种布局模式，专为创建更加灵活的页面布局而设计。主要特点：</p>
<p>核心概念：</p>
<ul>
<li>Flex容器(container)：设置<code>display: flex</code>的元素</li>
<li>Flex项目(items)：Flex容器的子元素</li>
<li>主轴(main axis)和交叉轴(cross axis)</li>
</ul>
<p>容器属性：</p>
<ul>
<li><code>flex-direction</code>: 决定主轴方向(row&#x2F;column)</li>
<li><code>flex-wrap</code>: 控制项目是否换行</li>
<li><code>justify-content</code>: 主轴上的对齐方式</li>
<li><code>align-items</code>: 交叉轴上的对齐方式</li>
<li><code>align-content</code>: 多行对齐方式</li>
</ul>
<h5 id="10-var-a-1-function-a-console-log-a-输出？"><a href="#10-var-a-1-function-a-console-log-a-输出？" class="headerlink" title="10. var a&#x3D;1;function a(){} console.log(a)输出？"></a><strong>10. var a&#x3D;1;function a(){} console.log(a)输出？</strong></h5><p>这段代码输出的结果是<code>1</code>。</p>
<p>这涉及到JavaScript中的变量提升和函数声明提升的机制：</p>
<ol>
<li>函数声明<code>function a()&#123;&#125;</code>会被整体提升到作用域顶部</li>
<li>变量声明<code>var a</code>也会被提升，但赋值不会</li>
<li>同名的函数声明和变量声明，函数声明优先级更高</li>
<li>执行到<code>var a=1</code>时，变量a被赋值为1，覆盖了之前的函数引用</li>
</ol>
<p>代码执行顺序等同于：</p>
<p>javascript</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 函数声明提升</span></span><br><span class="line"><span class="keyword">var</span> a;         <span class="comment">// 变量声明提升（此时a已经是函数）</span></span><br><span class="line">a = <span class="number">1</span>;         <span class="comment">// 赋值操作，a变成了数字1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure>

<p>这个问题考察了JavaScript中函数声明和变量声明的提升机制以及它们的优先级关系。理解这些规则对于避免代码中的潜在问题很重要。</p>
<h5 id="11-判断数据类型的方法-根据英文名字记忆"><a href="#11-判断数据类型的方法-根据英文名字记忆" class="headerlink" title="11. 判断数据类型的方法(根据英文名字记忆)"></a><strong>11. 判断数据类型的方法(根据英文名字记忆)</strong></h5><p><strong>1.typeof运算符</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>;           <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;hello&quot;</span>;      <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>;         <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>;    <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>();     <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42n</span>;          <span class="comment">// &quot;bigint&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;;           <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> [];           <span class="comment">// &quot;object&quot; (注意数组返回&quot;object&quot;)</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>;         <span class="comment">// &quot;object&quot; (这是一个历史遗留bug)</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;; <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.instanceof运算符</strong>：检测<strong>对象是否是某个构造函数的实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span>;  <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>3.Object.prototype.toString.call()</strong>：最准确的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">42</span>);        <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&quot;hello&quot;</span>);   <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>);      <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>); <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>);      <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;);        <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]);        <span class="comment">// &quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>4.Array.isArray()</strong>：专們用于检测数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([]);  <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;&#125;);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h5 id="12-闭包的实际应用"><a href="#12-闭包的实际应用" class="headerlink" title="12.闭包的实际应用"></a><strong>12.闭包的实际应用</strong></h5><p>闭包是指一个函数能够访问并记住其词法作用域，即使该函数在其词法作用域之外执行。实际应用包括：</p>
<p><strong>1.数据私有化&#x2F;封装</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;  <span class="comment">// 私有变量</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; count++; &#125;,</span><br><span class="line">        <span class="attr">decrement</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; count--; &#125;,</span><br><span class="line">        <span class="attr">getCount</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">createCounter</span>();</span><br><span class="line">counter.<span class="title function_">increment</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="title function_">getCount</span>()); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 无法直接访问count变量</span></span><br></pre></td></tr></table></figure>

<p><strong>2.模块模式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calculator = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 私有变量和函数</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x</span>) &#123; result += x; &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">subtract</span>(<span class="params">x</span>) &#123; result -= x; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公共API</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add,</span><br><span class="line">        subtract,</span><br><span class="line">        <span class="attr">getResult</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">calculator.<span class="title function_">add</span>(<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(calculator.<span class="title function_">getResult</span>()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p><strong>3.函数工厂</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createMultiplier</span>(<span class="params">multiplier</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * multiplier;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> double = <span class="title function_">createMultiplier</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> triple = <span class="title function_">createMultiplier</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">double</span>(<span class="number">5</span>)); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">triple</span>(<span class="number">5</span>)); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p><strong>4.setTimeout中保存循环变量</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i), <span class="number">100</span>); <span class="comment">// 输出：3,3,3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用闭包解决</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">index</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(index), <span class="number">100</span>); <span class="comment">// 输出：0,1,2</span></span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代解决方案：使用let替代var</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i), <span class="number">100</span>); <span class="comment">// 输出：0,1,2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5.事件处理和回调</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupButtonActions</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> buttons = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    buttons.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">button, index</span>) &#123;</span><br><span class="line">        button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 闭包可以访问index和button</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Button <span class="subst">$&#123;index&#125;</span> clicked`</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="13-写判读值相同isEqual-a-b-函数，a和b的数据类型不一定一样"><a href="#13-写判读值相同isEqual-a-b-函数，a和b的数据类型不一定一样" class="headerlink" title="13.写判读值相同isEqual(a,b)函数，a和b的数据类型不一定一样"></a><strong>13.写判读值相同isEqual(a,b)函数，a和b的数据类型不一定一样</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isEqual</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.判断基本类型或引用相同</span></span><br><span class="line">  <span class="keyword">if</span> (a === b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.如果其中一个是null或不是对象，且已经不相等，返回false</span></span><br><span class="line">  <span class="keyword">if</span> (a === <span class="literal">null</span> || b === <span class="literal">null</span> || <span class="keyword">typeof</span> a !== <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> b !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.处理日期对象</span></span><br><span class="line">  <span class="keyword">if</span> (a <span class="keyword">instanceof</span> <span class="title class_">Date</span> &amp;&amp; b <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">getTime</span>() === b.<span class="title function_">getTime</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.处理正则表达式</span></span><br><span class="line">  <span class="keyword">if</span> (a <span class="keyword">instanceof</span> <span class="title class_">RegExp</span> &amp;&amp; b <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">toString</span>() === b.<span class="title function_">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.检查是否为数组</span></span><br><span class="line">  <span class="keyword">const</span> isArrayA = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(a);</span><br><span class="line">  <span class="keyword">const</span> isArrayB = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(b);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个是数组一个不是，返回false</span></span><br><span class="line">  <span class="keyword">if</span> (isArrayA !== isArrayB) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理数组</span></span><br><span class="line">  <span class="keyword">if</span> (isArrayA &amp;&amp; isArrayB) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="property">length</span> !== b.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isEqual</span>(a[i], b[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6.处理普通对象</span></span><br><span class="line">  <span class="keyword">const</span> keysA = <span class="title class_">Object</span>.<span class="title function_">keys</span>(a);</span><br><span class="line">  <span class="keyword">const</span> keysB = <span class="title class_">Object</span>.<span class="title function_">keys</span>(b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (keysA.<span class="property">length</span> !== keysB.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保b中包含a的所有键，并且对应值相等</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keysA) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!keysB.<span class="title function_">includes</span>(key) || !<span class="title function_">isEqual</span>(a[key], b[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CSS-布局-Layout-vs-定位-Positioning-属性对比"><a href="#CSS-布局-Layout-vs-定位-Positioning-属性对比" class="headerlink" title="CSS 布局 (Layout) vs 定位 (Positioning) 属性对比"></a><strong>CSS 布局 (Layout) vs 定位 (Positioning) 属性对比</strong></h4><table>
<thead>
<tr>
<th><strong>概念分类</strong></th>
<th><strong>属性 (Property)</strong></th>
<th><strong>主要作用 (Main Purpose)</strong></th>
<th><strong>关键值&#x2F;说明 (Key Values&#x2F;Notes)</strong></th>
<th><strong>对文档流影响 (Impact on Document Flow)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>布局 (Layout)</strong></td>
<td><code>display</code></td>
<td>定义元素的基本框类型和布局方式（块级、内联、弹性、网格等）</td>
<td><code>block</code>, <code>inline</code>, <code>inline-block</code>, <code>flex</code>, <code>grid</code>, <code>none</code>, <code>table</code> 等</td>
<td><strong>根本性影响</strong>。决定元素如何参与或不参与文档流，是否独占一行等。</td>
</tr>
<tr>
<td></td>
<td><code>width</code>, <code>height</code> (及 <code>min/max</code> 变体)</td>
<td>设置元素的尺寸</td>
<td>像素 (<code>px</code>), 百分比 (<code>%</code>), <code>auto</code>, <code>vw</code>&#x2F;<code>vh</code> 等</td>
<td><strong>影响</strong>。决定元素在流中所占据的空间大小。</td>
</tr>
<tr>
<td></td>
<td><code>margin</code></td>
<td>设置元素<strong>外</strong>边距，控制元素之间的间距</td>
<td>可以是正负值，像素，百分比等。<code>auto</code> 可用于块级元素水平居中。</td>
<td><strong>影响</strong>。改变元素周围的空间，从而影响相邻元素在流中的位置。</td>
</tr>
<tr>
<td></td>
<td><code>padding</code></td>
<td>设置元素<strong>内</strong>边距，控制内容与边框的距离</td>
<td>通常是正值，像素，百分比等。</td>
<td><strong>影响</strong>。改变元素内部空间，可能影响元素（在 <code>content-box</code>下）的总尺寸，但不改变其在流中的基本性质。</td>
</tr>
<tr>
<td></td>
<td><code>box-sizing</code></td>
<td>定义 <code>width</code> 和 <code>height</code> 如何计算（是否包含 padding 和 border）</td>
<td><code>content-box</code> (默认), <code>border-box</code></td>
<td><strong>影响布局计算</strong>，但不直接改变元素的流行为（块级还是内联等）。</td>
</tr>
<tr>
<td></td>
<td><code>float</code></td>
<td>使元素脱离正常流，向左或右移动，允许文本或其他内联元素环绕</td>
<td><code>left</code>, <code>right</code>, <code>none</code></td>
<td><strong>部分脱离</strong>。元素本身仍在布局中（影响父容器高度等），但其位置脱离常规流，后续非 <code>clear</code> 元素会环绕它。</td>
</tr>
<tr>
<td></td>
<td><code>clear</code></td>
<td>指定元素旁边是否允许浮动元素</td>
<td><code>left</code>, <code>right</code>, <code>both</code>, <code>none</code></td>
<td><strong>影响</strong>。强制元素移动到浮动元素的下方，恢复正常流的部分顺序。</td>
</tr>
<tr>
<td></td>
<td>Flexbox 属性 (如 <code>flex-direction</code>, <code>justify-content</code>, <code>align-items</code>)</td>
<td>（用于 <code>display: flex</code> 容器）控制弹性项目在容器内的排列、对齐和分布</td>
<td>多种值，用于控制主轴、交叉轴对齐，换行等</td>
<td><strong>定义容器内项目的新文档流</strong>（弹性流）。</td>
</tr>
<tr>
<td></td>
<td>Grid 属性 (如 <code>grid-template-columns</code>, <code>grid-template-rows</code>, <code>gap</code>)</td>
<td>（用于 <code>display: grid</code> 容器）定义二维网格结构，并将项目放入网格单元</td>
<td>定义列宽、行高、区域、间距等</td>
<td><strong>定义容器内项目的新文档流</strong>（网格流）。</td>
</tr>
<tr>
<td></td>
<td><code>overflow</code></td>
<td>控制内容超出元素框时的处理方式</td>
<td><code>visible</code>, <code>hidden</code>, <code>scroll</code>, <code>auto</code></td>
<td><strong>主要影响内容呈现</strong>，一般不改变元素在流中的位置和大小（除非 <code>visible</code> 导致内容溢出影响后续元素）。</td>
</tr>
<tr>
<td></td>
<td><code>vertical-align</code></td>
<td>设置行内元素或表格单元格的垂直对齐方式</td>
<td><code>baseline</code>, <code>top</code>, <code>middle</code>, <code>bottom</code>, 长度值等</td>
<td><strong>影响</strong>。调整元素在<strong>行框 (line box)</strong> 或表格单元格内的垂直位置，属于流内微调。</td>
</tr>
<tr>
<td><strong>定位 (Positioning)</strong></td>
<td><code>position</code></td>
<td><strong>定义元素的定位机制</strong></td>
<td><code>static</code> (默认), <code>relative</code>, <code>absolute</code>, <code>fixed</code>, <code>sticky</code></td>
<td><strong>关键性影响</strong>。<code>relative</code> 不脱离但可偏移；<code>absolute</code>&#x2F;<code>fixed</code> 完全脱离；<code>sticky</code> 条件性脱离&#x2F;固定。</td>
</tr>
<tr>
<td></td>
<td><code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code></td>
<td>（当 <code>position</code> 非 <code>static</code> 时）<strong>设置定位元素相对于其参照物的偏移量</strong></td>
<td>长度值 (<code>px</code>, <code>%</code> 等), <code>auto</code></td>
<td><strong>不直接影响</strong>其他元素的常规文档流布局，仅移动该元素本身。脱离流的元素不再占据原始空间。</td>
</tr>
<tr>
<td></td>
<td><code>z-index</code></td>
<td>（当 <code>position</code> 非 <code>static</code> 时）<strong>设置定位元素的堆叠顺序（前后层次）</strong></td>
<td>整数 (可正可负), <code>auto</code></td>
<td><strong>不影响</strong>文档流布局，仅影响元素在 Z 轴（视觉前后）上的覆盖关系。</td>
</tr>
</tbody></table>
<p><strong>记忆小结：</strong></p>
<ul>
<li><strong>布局 (Layout)</strong> 属性更像是“规划师”，负责安排大家（元素）怎么站队、占多大地儿、彼此隔多远。它们主要在<strong>文档流内部</strong>工作，或者创建新的流上下文（Flex&#x2F;Grid）。</li>
<li><strong>定位 (Positioning)</strong> 属性更像是“调度员”，可以把某个特定的人（元素）叫出来，让他站到<strong>指定的位置</strong>，有时甚至可以让他“飞起来”（脱离地面&#x2F;文档流），或者叠在别人身上。<code>position</code> 是开启定位能力的总开关，<code>top/right/bottom/left</code> 是具体的坐标指令，<code>z-index</code> 是处理重叠时的前后顺序。</li>
</ul>
<h4 id="输入一个url会发生什么，尽量具体。"><a href="#输入一个url会发生什么，尽量具体。" class="headerlink" title="输入一个url会发生什么，尽量具体。"></a><strong>输入一个url会发生什么，尽量具体。</strong></h4><p><strong>我：</strong> 这个过程非常复杂，涉及浏览器、操作系统、网络协议等多个层面。我尝试尽可能详细地描述一下主要步骤：</p>
<ol>
<li><strong>用户输入与解析 (Input &amp; Parsing):</strong> 用户在浏览器地址栏输入 URL (Uniform Resource Locator)，比如 <code>https://www.example.com/path?query=1</code>。浏览器会解析这个 URL，识别出协议 (<code>https</code>)、域名 (<code>www.example.com</code>)、路径 (<code>/path</code>)、查询参数 (<code>?query=1</code>) 等。浏览器可能还会进行一些预处理，比如自动补全 <code>https://</code> 或者处理特殊字符。</li>
<li><strong>DNS 查询 (Domain Name System Lookup):</strong> 由于网络通信是基于 IP 地址的，浏览器需要将域名转换为对应的服务器 IP 地址。<ul>
<li><strong>浏览器缓存:</strong> 检查浏览器自身的 DNS 缓存。</li>
<li><strong>操作系统缓存:</strong> 检查操作系统的 DNS 缓存 (如 <code>hosts</code> 文件)。</li>
<li><strong>路由器缓存:</strong> 检查本地路由器的 DNS 缓存。</li>
<li><strong>ISP DNS 服务器:</strong> 向配置的本地 ISP (互联网服务提供商) 的 DNS 服务器发起递归查询请求。</li>
<li><strong>根域名服务器 -&gt; TLD 服务器 -&gt; 权威 DNS 服务器:</strong> ISP DNS 服务器会从根服务器开始，逐级查询顶级域名 (TLD, 如 <code>.com</code>) 服务器，最终找到负责 <code>example.com</code> 域名的权威 DNS 服务器，获取到 IP 地址。</li>
<li><strong>返回与缓存:</strong> 权威 DNS 服务器将 IP 地址返回给 ISP DNS 服务器，后者再返回给操作系统和浏览器，并进行缓存。</li>
</ul>
</li>
<li><strong>建立 TCP 连接 (TCP Connection Setup):</strong> 浏览器获取到 IP 地址后，需要与目标服务器建立 TCP 连接。这通常通过<strong>三次握手</strong>完成：<ul>
<li><strong>SYN:</strong> 浏览器（客户端）向服务器发送一个 SYN (Synchronize Sequence Numbers) 包，表示请求建立连接。</li>
<li><strong>SYN-ACK:</strong> 服务器收到 SYN 包后，如果同意连接，会回复一个 SYN-ACK (Synchronize-Acknowledgement) 包，表示确认收到请求并也请求建立连接。</li>
<li><strong>ACK:</strong> 浏览器收到 SYN-ACK 包后，再发送一个 ACK (Acknowledgement) 包给服务器，表示确认收到服务器的确认。至此，TCP 连接建立成功。</li>
</ul>
</li>
<li><strong>TLS&#x2F;SSL 握手 (If HTTPS):</strong> 如果 URL 是 <code>https</code> 协议，在 TCP 连接建立后，还需要进行 TLS (Transport Layer Security) &#x2F; SSL (Secure Sockets Layer) 握手，以建立加密信道：<ul>
<li>客户端发送 ClientHello (支持的加密套件、协议版本等)。</li>
<li>服务器回应 ServerHello (选定的加密套件、协议版本)，并发送其数字证书。</li>
<li>客户端验证证书的有效性（是否由受信任的 CA 颁发、是否过期、域名是否匹配等）。</li>
<li>（可能）客户端和服务器交换密钥信息（如使用 Diffie-Hellman 算法协商会话密钥）。</li>
<li>双方都生成会话密钥，并确认握手完成。之后的所有 HTTP 数据都将通过这个加密通道传输。</li>
</ul>
</li>
<li><strong>发送 HTTP(S) 请求 (Sending HTTP(S) Request):</strong> 浏览器构建一个 HTTP 请求报文，通过建立好的 TCP (和 TLS) 连接发送给服务器。请求报文通常包含：<ul>
<li><strong>请求行:</strong> 请求方法 (GET, POST等)、请求的资源路径 (<code>/path?query=1</code>)、HTTP 协议版本。</li>
<li><strong>请求头 (Headers):</strong> 包含各种附加信息，如 <code>Host</code> (目标域名)、<code>User-Agent</code> (浏览器标识)、<code>Accept</code> (可接受的内容类型)、<code>Cookie</code> (携带之前服务器设置的 Cookie)、<code>Connection: keep-alive</code> (建议保持 TCP 连接) 等。</li>
<li><strong>请求体 (Body):</strong> 对于 POST 请求等，会包含需要提交的数据。</li>
</ul>
</li>
<li><strong>服务器处理请求与响应 (Server Processing &amp; Response):</strong><ul>
<li>Web 服务器 (如 Nginx, Apache) 接收到请求。</li>
<li>根据请求路径和配置，可能将请求转发给后端应用服务器 (如 Node.js, Tomcat, PHP-FPM)。</li>
<li>后端应用处理业务逻辑，可能涉及数据库查询、调用其他服务等。</li>
<li>服务器构建一个 HTTP 响应报文，包含：<ul>
<li><strong>状态行:</strong> HTTP 协议版本、状态码 (如 <code>200 OK</code>, <code>404 Not Found</code>, <code>301 Moved Permanently</code>)、状态描述。</li>
<li><strong>响应头 (Headers):</strong> 如 <code>Content-Type</code> (响应体内容类型，如 <code>text/html</code>)、<code>Content-Length</code> (响应体大小)、<code>Set-Cookie</code> (要求浏览器设置 Cookie)、<code>Cache-Control</code> (缓存策略) 等。</li>
<li><strong>响应体 (Body):</strong> 实际的资源内容，如 HTML 文档、JSON 数据、图片等。</li>
</ul>
</li>
<li>服务器将响应报文通过 TCP 连接发送回浏览器。</li>
</ul>
</li>
<li><strong>浏览器接收与处理响应 (Browser Receiving &amp; Processing):</strong><ul>
<li>浏览器接收 HTTP 响应。</li>
<li><strong>解析 HTML:</strong> 如果响应类型是 <code>text/html</code>，浏览器开始解析 HTML 文档，构建 <strong>DOM (Document Object Model) 树</strong>。</li>
<li><strong>请求其他资源:</strong> 在解析 HTML 时，如果遇到外部资源引用（如 CSS 文件、JavaScript 文件、图片、字体），浏览器会<strong>并行或串行地</strong>发起新的 HTTP 请求去获取这些资源（过程类似步骤 2-6，但可能复用现有 TCP 连接 - HTTP Keep-Alive&#x2F;HTTP&#x2F;2 Multiplexing）。</li>
<li><strong>解析 CSS:</strong> 浏览器解析 CSS 文件（外部或内联样式），构建 <strong>CSSOM (CSS Object Model) 树</strong>。</li>
<li><strong>构建渲染树 (Render Tree):</strong> 结合 DOM 树和 CSSOM 树，创建渲染树。渲染树只包含需要显示的节点及其样式信息（<code>display: none</code> 的节点不会包含在内）。</li>
<li><strong>布局 (Layout &#x2F; Reflow):</strong> 根据渲染树，计算每个节点在屏幕上的精确位置和大小。</li>
<li><strong>绘制 (Paint &#x2F; Raster):</strong> 将渲染树的各个节点绘制成位图（像素）。浏览器可能会将页面分成多个层 (Layers) 来绘制。</li>
<li><strong>合成 (Composite):</strong> 将绘制好的各个层按照正确的顺序（考虑 <code>z-index</code> 等）合并到屏幕上显示。</li>
</ul>
</li>
<li><strong>JavaScript 执行:</strong><ul>
<li>在解析 HTML 时，如果遇到 <code>&lt;script&gt;</code> 标签（没有 <code>async</code> 或 <code>defer</code> 属性），HTML 解析会暂停，浏览器会下载（如果需要）并执行 JavaScript 代码。JS 代码可能会修改 DOM 或 CSSOM，这可能导致重新布局 (Reflow) 和重绘 (Repaint)。</li>
<li><code>defer</code> 的脚本会按顺序在 HTML 解析完成后、DOMContentLoaded 事件前执行。</li>
<li><code>async</code> 的脚本会在下载完成后立刻执行，可能在 HTML 解析完成前或后，执行顺序不确定，且会阻塞 HTML 解析。</li>
</ul>
</li>
<li><strong>页面加载完成与交互:</strong> 当所有资源（特别是初始渲染所需的）加载和处理完毕，页面显示完成。之后 JavaScript 可以响应用户的交互事件（点击、滚动、输入等）。</li>
</ol>
<h4 id="常见的tcp和udp协议"><a href="#常见的tcp和udp协议" class="headerlink" title="常见的tcp和udp协议"></a><strong>常见的tcp和udp协议</strong></h4><p><strong>我：</strong> 在 TCP&#x2F;IP 协议栈中，TCP 和 UDP 是传输层的两个主要协议。它们负责在网络中的应用程序之间传输数据。很多我们熟悉的上层应用协议都是基于它们构建的：</p>
<ul>
<li><strong>基于 TCP 的常见协议:</strong><ul>
<li><strong>HTTP&#x2F;HTTPS (HyperText Transfer Protocol &#x2F; Secure):</strong> 用于 Web 浏览器和 Web 服务器之间传输网页内容。</li>
<li><strong>FTP (File Transfer Protocol):</strong> 用于在网络上传输文件。</li>
<li><strong>SMTP (Simple Mail Transfer Protocol):</strong> 用于发送电子邮件。</li>
<li><strong>POP3 (Post Office Protocol version 3) &#x2F; IMAP (Internet Message Access Protocol):</strong> 用于接收电子邮件。</li>
<li><strong>SSH (Secure Shell):</strong> 用于安全的远程登录和执行命令。</li>
<li><strong>Telnet:</strong> 用于远程登录（不安全）。</li>
<li><strong>DNS:</strong> 虽然主要使用 UDP，但在需要传输大量数据（如区域传送）或要求可靠性时，也可以使用 TCP。</li>
</ul>
</li>
<li><strong>基于 UDP 的常见协议:</strong><ul>
<li><strong>DNS (Domain Name System):</strong> 主要用于域名到 IP 地址的快速查询。</li>
<li><strong>DHCP (Dynamic Host Configuration Protocol):</strong> 用于自动分配 IP 地址给网络中的设备。</li>
<li><strong>SNMP (Simple Network Management Protocol):</strong> 用于网络设备管理和监控。</li>
<li><strong>TFTP (Trivial File Transfer Protocol):</strong> 一个简化的文件传输协议。</li>
<li><strong>VoIP (Voice over IP):</strong> 很多实时语音通话应用使用 UDP 以减少延迟。</li>
<li><strong>在线游戏:</strong> 很多实时在线游戏的数据传输（如玩家位置同步）倾向于使用 UDP 以获得更快的响应。</li>
<li><strong>视频&#x2F;音频流:</strong> 一些实时流媒体协议（如 RTP）基于 UDP。</li>
<li><strong>NTP (Network Time Protocol):</strong> 用于同步网络中计算机的时间。</li>
<li><strong>QUIC (Quick UDP Internet Connections):</strong> HTTP&#x2F;3 使用的基础协议。</li>
</ul>
</li>
</ul>
<h4 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a><strong>tcp和udp的区别</strong></h4><p><strong>我：</strong> TCP (Transmission Control Protocol) 和 UDP (User Datagram Protocol) 是传输层的两个核心协议，它们的主要区别在于设计目标和提供的服务特性：</p>
<ol>
<li><strong>连接性:</strong><ul>
<li><strong>TCP:</strong> <strong>面向连接</strong>的协议。在数据传输前，必须先通过三次握手建立连接；传输结束后，需要通过四次挥手断开连接。</li>
<li><strong>UDP:</strong> <strong>无连接</strong>的协议。发送数据前不需要建立连接，直接将数据报 (Datagram) 发送出去。</li>
</ul>
</li>
<li><strong>可靠性:</strong><ul>
<li><strong>TCP:</strong> <strong>可靠的</strong>协议。通过序列号、确认应答 (ACK)、超时重传、数据校验等机制，确保数据能够<strong>有序、无差错、不丢失、不重复</strong>地到达目的地。</li>
<li><strong>UDP:</strong> <strong>不可靠的</strong>（或称“尽力而为”的）协议。不保证数据能否到达、是否按序到达、是否完整。它只负责将数据报发送出去，后续的可靠性需要应用层自己处理（如果需要的话）。</li>
</ul>
</li>
<li><strong>数据传输方式:</strong><ul>
<li><strong>TCP:</strong> 基于<strong>字节流 (Byte Stream)</strong>。数据没有明显的边界，像水流一样传输。接收方需要根据应用逻辑来划分数据。</li>
<li><strong>UDP:</strong> 基于<strong>数据报 (Datagram)</strong>。每个 UDP 包都是一个独立的消息单元，有明确的边界。接收方一次接收一个完整的报文。</li>
</ul>
</li>
<li><strong>效率与开销:</strong><ul>
<li><strong>TCP:</strong> 开销较大。因为需要维护连接状态、序列号、确认、重传、流量控制、拥塞控制等，头部信息也更复杂（至少 20 字节）。传输效率相对较低。</li>
<li><strong>UDP:</strong> 开销小。头部简单（固定 8 字节），没有复杂的控制机制。传输效率高，速度快。</li>
</ul>
</li>
<li><strong>流量控制与拥塞控制:</strong><ul>
<li><strong>TCP:</strong> 具备<strong>流量控制</strong>（使用滑动窗口，防止发送方过快地发送数据淹没接收方）和<strong>拥塞控制</strong>（根据网络状况动态调整发送速率，避免加剧网络拥堵）。</li>
<li><strong>UDP:</strong> <strong>没有</strong>流量控制和拥塞控制。发送方会以恒定速率（或应用层决定的速率）发送数据，不管接收方是否能处理，也不管网络是否拥堵。</li>
</ul>
</li>
<li><strong>应用场景:</strong><ul>
<li><strong>TCP:</strong> 适用于要求<strong>高可靠性、有序传输</strong>的应用。如网页浏览 (HTTP&#x2F;S)、文件传输 (FTP)、邮件 (SMTP&#x2F;POP3&#x2F;IMAP) 等。</li>
<li><strong>UDP:</strong> 适用于<strong>实时性要求高、能容忍少量丢包</strong>的应用，或者应用层自己实现了可靠性保障。如实时音视频通话 (VoIP)、在线游戏、DNS 查询、直播流、物联网数据上报等。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>特性</th>
<th>TCP (Transmission Control Protocol)</th>
<th>UDP (User Datagram Protocol)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>连接性</strong></td>
<td>面向连接 (Connection-oriented)</td>
<td>无连接 (Connectionless)</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>可靠 (Reliable)</td>
<td>不可靠 (Unreliable &#x2F; Best-effort)</td>
</tr>
<tr>
<td><strong>传输方式</strong></td>
<td>字节流 (Byte Stream)</td>
<td>数据报 (Datagram)</td>
</tr>
<tr>
<td><strong>顺序保证</strong></td>
<td>有序 (Ordered)</td>
<td>无序 (Unordered)</td>
</tr>
<tr>
<td><strong>流量控制</strong></td>
<td>有 (Flow Control)</td>
<td>无</td>
</tr>
<tr>
<td><strong>拥塞控制</strong></td>
<td>有 (Congestion Control)</td>
<td>无</td>
</tr>
<tr>
<td><strong>速度&#x2F;效率</strong></td>
<td>相对慢 &#x2F; 效率低</td>
<td>快 &#x2F; 效率高</td>
</tr>
<tr>
<td><strong>头部开销</strong></td>
<td>较大 (≥ 20 bytes)</td>
<td>小 (8 bytes)</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>Web, Email, File Transfer (可靠性优先)</td>
<td>Streaming, VoIP, DNS, Games (实时性优先)</td>
</tr>
</tbody></table>
<h4 id="你了解防抖和节流吗？它们的区别是什么？"><a href="#你了解防抖和节流吗？它们的区别是什么？" class="headerlink" title="你了解防抖和节流吗？它们的区别是什么？"></a><strong>你了解防抖和节流吗？它们的区别是什么？</strong></h4><p><strong>我：</strong> 是的，我了解防抖 (Debounce) 和节流 (Throttle)。它们都是用来优化高频触发事件（比如 <code>window.resize</code>, <code>scroll</code>, <code>input</code> 输入等）处理函数执行频率的技术，目的是提升性能和避免不必要的计算或请求。</p>
<ul>
<li><strong>防抖 (Debounce):</strong><ul>
<li><strong>策略:</strong> <strong>当事件持续触发时，并不会执行处理函数，只有当事件停止触发后，等待一个指定的时间间隔（delay），如果这个间隔内没有再次触发事件，才会执行一次处理函数。如果在这个间隔内事件又被触发了，则重新计时</strong>。</li>
<li><strong>好比:</strong> 电梯关门。只要有人在持续按开门按钮，电梯门就不会关。只有当最后一个人进来，并且在指定时间内（比如 3 秒）没有人再按开门按钮，电梯门才会关闭。</li>
<li>应用场景:<ul>
<li>搜索框输入建议（用户停止输入后再发请求）。</li>
<li>窗口大小调整后重新计算布局（只在用户调整完毕后计算一次）。</li>
<li>表单验证（用户停止输入后再进行校验）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>节流 (Throttle):</strong><ul>
<li><strong>策略:</strong> 确保一个函数在<strong>指定的时间间隔内最多只执行一次</strong>。无论事件触发多频繁，处理函数都会以固定的频率（如每 200 毫秒）执行一次。</li>
<li><strong>好比:</strong> 游戏技能冷却。按键按得再快，技能也只能在冷却时间结束后才能再次释放。或者像地铁的闸机，固定时间内只能通过一个人。</li>
<li>应用场景:<ul>
<li>页面滚动事件监听，用于判断是否到达某个位置（没必要每次滚动都计算，每隔几百毫秒检查一次即可）。</li>
<li>拖拽操作的实时更新（限制更新频率）。</li>
<li>高频点击按钮防止重复提交（比如限制 1 秒内只能提交一次）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>核心区别:</strong><ul>
<li><strong>防抖</strong>关注的是事件<strong>停止触发</strong>后的那一次执行，它会“取消”之前的等待，重新开始计时。适用于只需要最终结果的场景。</li>
<li><strong>节流</strong>关注的是在<strong>固定时间间隔内</strong>最多执行一次，它保证了函数执行的频率不会过高。适用于需要周期性响应的场景。</li>
</ul>
</li>
</ul>
<h4 id="你知道事件委托吗？能解释一下吗？"><a href="#你知道事件委托吗？能解释一下吗？" class="headerlink" title="你知道事件委托吗？能解释一下吗？"></a><strong>你知道事件委托吗？能解释一下吗？</strong></h4><p><strong>我：</strong> 是的，我知道事件委托 (Event Delegation)。</p>
<ul>
<li><strong>概念:</strong> 它是一种利用<strong>事件冒泡 (Event Bubbling)</strong> 机制，将事件监听器添加到<strong>父元素</strong>上，而不是直接添加到多个子元素上，用来管理一群子元素上发生的同类型事件的技术。</li>
<li><strong>原理:</strong> 当子元素上的事件被触发时，这个事件会沿着 DOM 树向上传播（冒泡）到其祖先元素。我们可以在父元素（或更上层的祖先元素）上设置一个监听器来捕获这个冒泡上来的事件。在父元素的监听函数内部，我们可以通过检查事件对象 <code>event</code> 的 <code>target</code> 属性 (<code>event.target</code>) 来判断事件<strong>实际起源于哪个子元素</strong>。如果这个 <code>target</code> 是我们关心的子元素类型，我们就可以执行相应的处理逻辑。</li>
<li>优点:<ol>
<li><strong>性能提升:</strong> 减少了需要添加到页面上的事件监听器的数量，从而减少了内存占用和 DOM 操作，尤其在子元素非常多的时候效果显著。</li>
<li><strong>动态元素支持:</strong> 对于后续通过 JavaScript 动态添加到父元素中的子元素，无需再单独为它们绑定事件监听器，事件委托的机制会自动处理这些新元素的事件。</li>
<li><strong>代码简化:</strong> 可以将多个子元素的事件处理逻辑集中到父元素的监听器中，使代码更简洁、易于维护。</li>
</ol>
</li>
</ul>
<h4 id="你知道事件的传递流程吗？（冒泡和捕获）"><a href="#你知道事件的传递流程吗？（冒泡和捕获）" class="headerlink" title="你知道事件的传递流程吗？（冒泡和捕获）"></a><strong>你知道事件的传递流程吗？（冒泡和捕获）</strong></h4><p><strong>我：</strong> 是的，我知道 DOM 事件的传递流程，它包含三个阶段：</p>
<ol>
<li><strong>捕获阶段 (Capturing Phase):</strong><ul>
<li>事件从 <code>window</code> 对象开始，沿着 DOM 树<strong>向下传播</strong>，经过目标元素的各个祖先节点，一直到达事件的目标元素 (Target Element)。</li>
<li>在这个阶段，如果在路径上的任何节点注册了<strong>捕获类型</strong>的事件监听器 (<code>addEventListener</code> 的第三个参数 <code>useCapture</code> 设置为 <code>true</code>)，那么这些监听器会被依次触发。</li>
</ul>
</li>
<li><strong>目标阶段 (Target Phase):</strong><ul>
<li>事件到达<strong>目标元素</strong>。</li>
<li>浏览器会触发注册在目标元素自身上的事件监听器。在这个阶段触发的监听器，无论是捕获还是冒泡类型注册的，都会被执行（执行顺序取决于注册顺序等因素，但它们都在目标阶段被调用）。</li>
</ul>
</li>
<li><strong>冒泡阶段 (Bubbling Phase):</strong><ul>
<li>事件从<strong>目标元素</strong>开始，沿着 DOM 树<strong>向上传播</strong>，经过其各个祖先节点，最终回到 <code>window</code> 对象。</li>
<li>在这个阶段，如果在路径上的任何节点注册了<strong>冒泡类型</strong>的事件监听器 (<code>addEventListener</code> 的第三个参数 <code>useCapture</code> 设置为 <code>false</code> 或省略，这是默认行为)，那么这些监听器会被依次触发。</li>
<li><strong>注意:</strong> 不是所有事件都会冒泡，例如 <code>focus</code>, <code>blur</code>, <code>load</code>, <code>unload</code> 等事件默认不冒泡。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>控制流程:</strong><ul>
<li>我们可以使用 <code>event.stopPropagation()</code> 方法在任何阶段阻止事件继续传播（阻止后续的捕获或冒泡）。</li>
<li><code>event.stopImmediatePropagation()</code> 不仅阻止传播，还会阻止<strong>同一元素上</strong>绑定<strong>同一事件类型</strong>的<strong>其他监听器</strong>被执行。</li>
</ul>
</li>
<li><strong>事件委托</strong> 主要利用的就是<strong>冒泡阶段</strong>。</li>
</ul>
<h4 id="CDN是什么"><a href="#CDN是什么" class="headerlink" title="CDN是什么?"></a><strong>CDN是什么?</strong></h4><p><strong>我：</strong> CDN 是 <strong>Content Delivery Network</strong> (内容分发网络) 的缩写。</p>
<ul>
<li><strong>概念:</strong> 它是一个由<strong>地理上分散</strong>的服务器（称为<strong>边缘节点</strong>或 PoP - Point of Presence）组成的网络，这些服务器协同工作，旨在更快、更可靠地将静态或动态 Web 内容（如图片、CSS 文件、JavaScript 文件、视频、HTML 页面等）分发给终端用户。</li>
<li>工作原理:<ol>
<li>网站的原始文件存储在<strong>源服务器 (Origin Server)</strong> 上。</li>
<li>CDN 服务商将这些文件的副本<strong>缓存</strong>到其全球各地的<strong>边缘服务器</strong>上。</li>
<li>当用户尝试访问网站内容时，CDN 的智能路由系统（通常基于 DNS）会将用户的请求导向到离用户<strong>地理位置最近</strong>或<strong>网络延迟最低</strong>的那个<strong>边缘服务器</strong>。</li>
<li>该边缘服务器直接将缓存的内容响应给用户。如果边缘服务器没有缓存该内容或缓存已过期，它会先向源服务器请求最新的内容，缓存后再响应给用户。</li>
</ol>
</li>
<li>主要优点:<ol>
<li><strong>加速网站加载速度:</strong> 用户从更近的服务器获取内容，大大减少了网络延迟 (Latency)。</li>
<li><strong>提高网站可用性和冗余:</strong> 即使某个边缘服务器或源服务器出现故障，请求也可以被路由到其他健康的服务器，减少了单点故障的风险。</li>
<li><strong>降低源服务器负载和带宽成本:</strong> 大部分用户请求由 CDN 边缘服务器处理，减轻了源服务器的压力和带宽消耗。</li>
<li><strong>增强网站的全球可扩展性:</strong> 可以轻松应对全球范围内的用户访问和流量高峰。</li>
<li><strong>提升安全性:</strong> 许多 CDN 提供商还提供额外的安全服务，如 DDoS 攻击缓解、Web 应用防火墙 (WAF) 等。</li>
</ol>
</li>
</ul>

    </div>
  </article>


</section>
    <footer id="footer" role="contentinfo">
    <div>&copy; 2025 <a href="/">DayBreak</a>.
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Designed by <a href="http://rainylog.com" target="_blank">Rainy.</a>
	</div>
</footer><!-- end #footer -->

  </div>
  
<script src="/lib/fancybox/dist/jquery.fancybox.min.js"></script>


  
<script src="/js/helper.js"></script>

  
<script src="/js/_third-party/gitment.js"></script>

</body>
</html>