<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>tag: 八股文 | DayBreak</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="坚持与从俗不同信仰的困难">
<meta property="og:type" content="website">
<meta property="og:title" content="DayBreak">
<meta property="og:url" content="http://example.com/tags/%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="DayBreak">
<meta property="og:description" content="坚持与从俗不同信仰的困难">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Xiaoyi Hao">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="DayBreak" type="application/atom+xml">
  
  
  
  
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0.css">

  
<link rel="stylesheet" href="/lib/fancybox/dist/jquery.fancybox.min.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<script src="/lib/jquery/dist/jquery.min.js"></script>

  
  
  
  
<meta name="generator" content="Hexo 7.3.0"></head>
<body>
  <div id="wrapper">
    <header id="header" class="clearfix">
	<a id="logo" href="/" title="DayBreak">DayBreak</a>
	
	<nav id="nav-menu" class="clearfix">
		<form id="search" method="post" action="./" role="search">
			<input id="search-input" type="text" name="s" class="inputbox" value="Search" onfocus="if (value =='Search'){value =''}" onblur="if (value ==''){value='Search'}">
		</form>
		<ul>
      
				
        <li><a class="main-nav-link" href="/">Home</a></li>
      
				
        <li><a class="main-nav-link" href="/archives">Archives</a></li>
      
		</ul>
	</nav>
</header>
    <section id="main" class="clearfix">
  <article class="post-detail">
    <h1 class="post-title"><a href="/">八股积累-02</a></h1>
    <ul class="post-meta">
  <li><i class="fa fa-user"></i> Author Xiaoyi Hao</li>
  <li><i class="fa fa-calendar"></i> Date Apr 15</li>
  <li><i class="fa fa-folder"></i> Categories
  
    no_categories
  
  </li>
</ul>
    <div class="post-content">
      <p><strong>1、HTTP缓存</strong></p>
<p>HTTP缓存是一种优化技术，浏览器或中间缓存服务器（如CDN）将请求过的Web资源（如HTML页面、图片、CSS、JS文件）存储起来。当用户再次请求相同资源时，可以直接从本地缓存或邻近的缓存服务器中获取，而无需向源服务器发送请求。这大大减少了请求延迟，节省了网络带宽，降低了服务器负载，提升了用户体验。</p>
<p>HTTP缓存主要分为两大类：</p>
<ul>
<li><strong>强制缓存 (Strong Cache):</strong><ul>
<li>浏览器直接检查本地缓存的有效性，无需向服务器发送请求。</li>
</ul>
</li>
<li><strong>协商缓存 (Negotiation Cache &#x2F; Conditional Cache):</strong><ul>
<li>强制缓存失效后（或者<code>Cache-Control: no-cache</code>），浏览器会向服务器发送一个条件请求。</li>
<li>服务器根据请求中的条件判断资源是否有更新。</li>
<li>如果服务器判断资源未改变，返回 <code>304 Not Modified</code>，浏览器便可安全地使用本地缓存。</li>
</ul>
</li>
</ul>
<p><strong>缓存流程:</strong> 浏览器请求资源 -&gt; 检查强制缓存 (Cache-Control&#x2F;Expires) -&gt; 若命中且有效，直接使用 (200 from cache) -&gt; 若强制缓存无效或不存在 -&gt; 发起HTTP请求，带上协商缓存头 (If-Modified-Since&#x2F;If-None-Match) -&gt; 服务器检查协商缓存头 -&gt; 若资源未改变，返回304，浏览器使用本地缓存 -&gt; 若资源已改变，返回200和新资源，浏览器更新缓存。</p>
<p><strong>2、跨域</strong></p>
<p>跨域是指浏览器出于安全原因，限制网页脚本访问不同源 (Origin) 的资源。<strong>源</strong>由<strong>协议 (Protocol)</strong>、<strong>域名 (Domain&#x2F;Host)</strong> 和 <strong>端口 (Port)</strong> 三者共同定义。只要这三者中有一个不同，就构成跨域。</p>
<p>这是浏览器的<strong>同源策略 (Same-Origin Policy, SOP)</strong> 导致的，它是一个重要的安全基石，旨在防止恶意网站读取或篡改其他网站的敏感数据。</p>
<p>常见的跨域场景包括：</p>
<ul>
<li>AJAX 请求访问不同源的 API。</li>
<li>页面中的 <code>&lt;iframe&gt;</code> 加载不同源的页面，并试图通过脚本进行交互。</li>
<li>Web 字体、Canvas&#x2F;WebGL 绘制使用了不同源的图片等。</li>
</ul>
<p><strong>3、前端缓存有哪几种</strong></p>
<p>前端缓存是指将数据或资源存储在客户端（浏览器）的技术，以提高应用性能和用户体验。主要有以下几种：</p>
<ol>
<li><strong>HTTP 缓存:</strong> (前面已详细说明) 浏览器根据 HTTP 响应头自动处理的资源缓存（强缓存、协商缓存）。这是最基础也是应用最广泛的缓存。</li>
<li><strong>LocalStorage:</strong> HTML5 Web Storage API 提供的<strong>持久化本地存储方案</strong>。以<strong>键值对（Key-Value）形式</strong>存储<strong>字符串</strong>数据。<strong>除非用户手动清除浏览器数据或代码主动删除，否则数据会一直存在</strong>，即使关闭浏览器或标签页也不会消失。容量通常为 5-10MB。<strong>同源限制</strong>。</li>
<li><strong>SessionStorage:</strong> 与 LocalStorage 类似，也是键值对存储字符串。但它的生命周期与<strong>浏览器会话</strong>绑定，即<strong>当标签页或浏览器窗口关闭后，SessionStorage 中存储的数据会被清除</strong>。容量和同源限制同 LocalStorage。适合存储临时性的会话数据。</li>
<li><strong>IndexedDB:</strong> 一个在浏览器中运行的、功能强大的<strong>事务型</strong>数据库系统。允许存储大量的结构化数据（包括文件&#x2F;Blob），并支持索引以实现高性能查询。API 是<strong>异步</strong>的。比 LocalStorage&#x2F;SessionStorage 复杂，但提供了更强大的数据管理能力。同源限制。</li>
<li><strong>Cookies:</strong> 小段文本信息，由服务器通过 <code>Set-Cookie</code> 响应头发送给浏览器，浏览器将其存储，并在后续对<strong>同一服务器</strong>的<strong>每次</strong>请求中通过 <code>Cookie</code> 请求头自动带上。**主要用于用户身份认证、会话管理、跟踪用户行为等。缺点是容量小（约 4KB），且每次请求都会携带，可能造成带宽浪费。**可以通过设置 <code>HttpOnly</code> 防止脚本访问，提高安全性。</li>
</ol>
<p><strong>4、防抖和节流如何实现</strong></p>
<p>防抖 (Debounce) 和节流 (Throttle) 是两种优化高频触发事件（如 <code>resize</code>, <code>scroll</code>, <code>input</code> 等）的常用技术，它们都通过<strong>返回一个新函数</strong>来实现。</p>
<ul>
<li><p><strong>防抖 (Debounce) 实现:</strong></p>
<ul>
<li><strong>目标:</strong> 在事件触发后，等待一段指定的延迟时间。如果在这段延迟时间内没有新的事件触发，则执行目标函数；如果延迟时间内又有新的事件触发，则<strong>重新计时</strong>。简而言之：<strong>只在最后一次触发后的指定延迟后执行一次</strong>。</li>
<li><strong>实现思路:</strong> 使用 <code>setTimeout</code> 来管理延迟执行。每次事件触发时，先清除之前的定时器，然后设置一个新的定时器。</li>
</ul>
<p>JavaScript</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; func 要执行的目标函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; delay 延迟时间 (ms)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Function</span>&#125; 包装后的防抖函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeoutId = <span class="literal">null</span>; <span class="comment">// 定时器 ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个新函数，这个函数将作为事件处理程序</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 保存 this 上下文和参数</span></span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已有定时器，则清除它（取消之前的延迟执行）</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeoutId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置一个新的定时器</span></span><br><span class="line">    timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 延迟时间到了，执行目标函数</span></span><br><span class="line">      <span class="comment">// 使用 apply 来保持正确的 this 指向和传递参数</span></span><br><span class="line">      func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">      timeoutId = <span class="literal">null</span>; <span class="comment">// 执行完毕，重置 timeoutId (可选)</span></span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 使用示例 ---</span></span><br><span class="line"><span class="comment">// const debouncedHandler = debounce(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&#x27;窗口大小已停止变化一段时间&#x27;);</span></span><br><span class="line"><span class="comment">// &#125;, 500);</span></span><br><span class="line"><span class="comment">// window.addEventListener(&#x27;resize&#x27;, debouncedHandler);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>节流 (Throttle) 实现:</strong></p>
<ul>
<li><strong>目标:</strong> 在指定的<strong>时间间隔内，最多只执行一次</strong>目标函数。无论事件触发多频繁，都会以固定的频率执行。简而言之：<strong>固定时间内只执行一次，多余的触发忽略</strong>。</li>
<li><strong>实现思路 (基于定时器):</strong> 使用一个标志位（或检查定时器是否存在）来判断是否可以执行。如果可以执行，则立即执行（或设置定时器执行），然后设置一个定时器，在时间间隔结束后才允许下一次执行。</li>
</ul>
<p>JavaScript</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数 (基于定时器，首次触发可能延迟)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Function</span>&#125; func 要执行的目标函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; interval 时间间隔 (ms)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Function</span>&#125; 包装后的节流函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeoutId = <span class="literal">null</span>; <span class="comment">// 定时器 ID</span></span><br><span class="line">  <span class="keyword">let</span> lastArgs = <span class="literal">null</span>; <span class="comment">// 保存最后一次的参数</span></span><br><span class="line">  <span class="keyword">let</span> lastThis = <span class="literal">null</span>; <span class="comment">// 保存最后一次的 this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个新函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    lastArgs = args; <span class="comment">// 保存参数</span></span><br><span class="line">    lastThis = <span class="variable language_">this</span>; <span class="comment">// 保存 this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果定时器不存在，表示可以设置新的执行</span></span><br><span class="line">    <span class="keyword">if</span> (!timeoutId) &#123;</span><br><span class="line">      timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 时间间隔到了，执行函数</span></span><br><span class="line">        func.<span class="title function_">apply</span>(lastThis, lastArgs);</span><br><span class="line">        <span class="comment">// 清除定时器，允许下一次设置</span></span><br><span class="line">        timeoutId = <span class="literal">null</span>;</span><br><span class="line">        lastArgs = <span class="literal">null</span>;</span><br><span class="line">        lastThis = <span class="literal">null</span>;</span><br><span class="line">      &#125;, interval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果定时器已存在，则忽略本次触发（或者也可以选择在定时器结束后执行最后一次触发的调用）</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 使用示例 (另一种常见实现：首次立即执行，之后节流) ---</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttleImmediate</span>(<span class="params">func, interval</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span>; <span class="comment">// 标志位，表示是否可以立即执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) &#123;</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 如果不能运行，则忽略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    canRun = <span class="literal">false</span>; <span class="comment">// 标记为不能立即运行</span></span><br><span class="line">    <span class="comment">// 立即执行一次</span></span><br><span class="line">    func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置定时器，在 interval 毫秒后恢复 canRun</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, interval);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// const throttledHandler = throttleImmediate(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&#x27;滚动事件被节流处理&#x27;);</span></span><br><span class="line"><span class="comment">// &#125;, 200);</span></span><br><span class="line"><span class="comment">// window.addEventListener(&#x27;scroll&#x27;, throttledHandler);</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>5、代码题， 大数相加</strong></p>
<p>当两个数字非常大，超过了 JavaScript 的 <code>Number.MAX_SAFE_INTEGER</code> (2^53 - 1)，直接使用 <code>+</code> 运算符会丢失精度。这时需要将数字作为字符串处理，模拟手动加法的过程。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大数相加</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; num1 第一个大数（字符串形式）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; num2 第二个大数（字符串形式）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">string</span>&#125; 两个大数相加的结果（字符串形式）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addBigIntegers</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = num1.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 指向 num1 末尾</span></span><br><span class="line">  <span class="keyword">let</span> j = num2.<span class="property">length</span> - <span class="number">1</span>; <span class="comment">// 指向 num2 末尾</span></span><br><span class="line">  <span class="keyword">let</span> carry = <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 结果字符串</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从个位开始，只要还有数字位或者有进位，就继续循环</span></span><br><span class="line">  <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取当前位的数字，如果索引&lt;0，则视为 0</span></span><br><span class="line">    <span class="keyword">const</span> digit1 = i &gt;= <span class="number">0</span> ? <span class="built_in">parseInt</span>(num1[i]) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> digit2 = j &gt;= <span class="number">0</span> ? <span class="built_in">parseInt</span>(num2[j]) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前位的和（加上进位）</span></span><br><span class="line">    <span class="keyword">const</span> sum = digit1 + digit2 + carry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前位的结果是 sum % 10</span></span><br><span class="line">    <span class="keyword">const</span> currentDigit = sum % <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 新的进位是 Math.floor(sum / 10)</span></span><br><span class="line">    carry = <span class="title class_">Math</span>.<span class="title function_">floor</span>(sum / <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前位的结果拼接到结果字符串的前面</span></span><br><span class="line">    result = currentDigit + result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动索引</span></span><br><span class="line">    i--;</span><br><span class="line">    j--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果结果是 &#x27;0&#x27;，并且输入不是 &#x27;0&#x27; + &#x27;0&#x27;，确保返回 &#x27;0&#x27; 而不是空串（虽然此逻辑下不会是空串）</span></span><br><span class="line">  <span class="comment">// 此处可以简化，因为循环条件保证了至少处理一次</span></span><br><span class="line">  <span class="comment">// if (result === &#x27;&#x27; &amp;&amp; (num1 !== &#x27;0&#x27; || num2 !== &#x27;0&#x27;)) return &#x27;0&#x27;; // 防御性代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 示例测试 ---</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addBigIntegers</span>(<span class="string">&quot;123&quot;</span>, <span class="string">&quot;456&quot;</span>)); <span class="comment">// 输出: &quot;579&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addBigIntegers</span>(<span class="string">&quot;99&quot;</span>, <span class="string">&quot;1&quot;</span>));    <span class="comment">// 输出: &quot;100&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addBigIntegers</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;999&quot;</span>));   <span class="comment">// 输出: &quot;1000&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addBigIntegers</span>(<span class="string">&quot;12345678901234567890&quot;</span>, <span class="string">&quot;98765432109876543210&quot;</span>)); <span class="comment">// 输出: &quot;111111111001111111100&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addBigIntegers</span>(<span class="string">&quot;0&quot;</span>, <span class="string">&quot;0&quot;</span>));     <span class="comment">// 输出: &quot;0&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>实现思路:</strong></p>
<ol>
<li>初始化两个指针 <code>i</code> 和 <code>j</code> 分别指向两个数字字符串的末尾，进位 <code>carry</code> 为 0，结果字符串 <code>result</code> 为空。</li>
<li>使用 <code>while</code> 循环，条件是 <code>i</code> 或 <code>j</code> 没有越界（还没处理完所有位），或者 <code>carry</code> 大于 0（最高位有进位）。</li>
<li>在循环内部：<ul>
<li>获取 <code>num1[i]</code> 和 <code>num2[j]</code> 对应的数字。如果索引已经小于 0，则该位视为 0。使用 <code>parseInt()</code> 转换字符为数字。</li>
<li>计算 <code>sum = digit1 + digit2 + carry</code>。</li>
<li>当前位的值是 <code>sum % 10</code>。</li>
<li>新的进位是 <code>Math.floor(sum / 10)</code>。</li>
<li>将当前位的值（<code>sum % 10</code>）<strong>拼接</strong>到 <code>result</code> 字符串的<strong>前面</strong>。</li>
<li>将 <code>i</code> 和 <code>j</code> 向前移动（<code>i--</code>, <code>j--</code>）。</li>
</ul>
</li>
<li>循环结束后，<code>result</code> 就是最终的、正确顺序的和。</li>
</ol>
<h4 id="缓存策略应用："><a href="#缓存策略应用：" class="headerlink" title="缓存策略应用："></a><strong>缓存策略应用：</strong></h4><ul>
<li><strong>不常变化的静态资源（CSS, JS, 图片, 字体）：</strong> 设置很长的<code>max-age</code>（例如一年 <code>max-age=31536000</code>），并配合<strong>内容哈希或版本号</strong>的文件名（如 <code>style.a1b2c3d4.css</code> 或 <code>main.v1.js</code>）。当文件内容更新时，文件名改变，浏览器会请求新资源；文件名不变时，则长期利用缓存。</li>
<li><strong>可能会变化的资源（HTML，某些API数据）：</strong> 使用 <code>no-cache</code> 或 <code>max-age=0</code>，强制每次使用前进行验证（发送<code>If-Modified-Since</code>或<code>If-None-Match</code>请求）。如果资源未变，服务器返回<code>304</code>，只传输少量头部信息，仍然比重新下载整个资源快。</li>
<li><strong>敏感数据或频繁变化的API数据：</strong> 使用<code>no-store</code>，完全禁止缓存。</li>
</ul>
<h4 id="那么请你详细描述一下-从在浏览器地址栏输入一个URL-到最终页面渲染出来的整个过程"><a href="#那么请你详细描述一下-从在浏览器地址栏输入一个URL-到最终页面渲染出来的整个过程" class="headerlink" title="那么请你详细描述一下,从在浏览器地址栏输入一个URL.到最终页面渲染出来的整个过程."></a>那么请你详细描述一下,从在浏览器地址栏输入一个URL.到最终页面渲染出来的整个过程.</h4><ol>
<li><p><strong>用户输入与URL解析:</strong></p>
<ul>
<li>用户在浏览器地址栏输入URL（例如 <code>https://www.example.com/path?query=value#fragment</code>）。</li>
<li>浏览器首先解析这个URL，识别出协议 (<code>https</code>)、域名 (<code>www.example.com</code>)、端口（HTTPS默认为443）、路径 (<code>/path</code>)、查询参数 (<code>?query=value</code>) 和片段标识符 (<code>#fragment</code>)。</li>
<li>如果输入的是搜索词而非URL，浏览器会使用默认搜索引擎将其转换为搜索结果页面的URL。</li>
</ul>
</li>
<li><p><strong>检查缓存:</strong></p>
<ul>
<li><p>浏览器缓存:</p>
<p>浏览器首先检查其本地缓存（内存缓存、磁盘缓存）。它会根据URL和缓存策略（</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires</span><br></pre></td></tr></table></figure>

<p>）判断是否存在有效（未过期）的资源副本。</p>
<ul>
<li><strong>强缓存命中:</strong> 如果找到未过期的有效副本（在<code>max-age</code>内），浏览器直接从缓存读取资源，不发起网络请求。这是最快的情况（可能看到 <code>200 OK (from memory cache)</code> 或 <code>200 OK (from disk cache)</code>）。整个过程可能在这里就结束了HTML文档的获取。</li>
<li><strong>协商缓存:</strong> 如果资源已过期或被标记为<code>no-cache</code>，浏览器需要向服务器验证资源是否更新。它会准备发起网络请求，并在请求头中带上缓存标识（如<code>If-Modified-Since</code>或<code>If-None-Match</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>DNS域名解析:</strong></p>
<ul>
<li><p>如果缓存未命中或需要验证，浏览器需要知道目标服务器的IP地址。</p>
</li>
<li><p><strong>查找本地缓存:</strong> 浏览器先检查自身DNS缓存 -&gt; 操作系统<code>hosts</code>文件 -&gt; 操作系统DNS缓存。</p>
</li>
<li><p><strong>路由器缓存:</strong> 如果本地没有，查询路由器的DNS缓存。</p>
</li>
<li><p><strong>ISP DNS服务器:</strong> 查询本地ISP（互联网服务提供商）提供的DNS服务器。</p>
</li>
<li><p>根域名服务器查询 (递归过程):</p>
<p>如果ISP DNS服务器也没有缓存，它会发起递归查询：</p>
<ul>
<li>ISP DNS问 <strong>根域名服务器</strong>: “.com” 域名的顶级域（TLD）服务器地址是什么？</li>
<li>根服务器返回 <strong>TLD服务器</strong> 地址。</li>
<li>ISP DNS问 <strong>TLD服务器</strong>: “example.com” 的权威名称服务器（Authoritative Name Server）地址是什么？</li>
<li>TLD服务器返回 <strong>权威名称服务器</strong> 地址。</li>
<li>ISP DNS问 <strong>权威名称服务器</strong>: “<a target="_blank" rel="noopener" href="https://www.example.com/">www.example.com</a>“ 的IP地址是什么？</li>
<li>权威名称服务器返回最终的IP地址。</li>
</ul>
</li>
<li><p><strong>结果缓存:</strong> ISP DNS服务器缓存这个结果（遵循TTL），并返回给操作系统，操作系统再返回给浏览器。</p>
</li>
</ul>
</li>
<li><p><strong>建立TCP连接:</strong></p>
<ul>
<li>浏览器获得IP地址和端口号（HTTP默认80，HTTPS默认443）后，会尝试与服务器建立TCP连接。</li>
<li>这通过三次握手 (Three-way Handshake)完成：<ol>
<li><strong>SYN:</strong> 浏览器发送一个SYN（同步）包到服务器，请求建立连接。</li>
<li><strong>SYN-ACK:</strong> 服务器收到SYN后，如果同意连接，会回复一个SYN-ACK（同步确认）包。</li>
<li><strong>ACK:</strong> 浏览器收到SYN-ACK后，发送一个ACK（确认）包给服务器。连接建立成功。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>TLS&#x2F;SSL握手 (如果是HTTPS):</strong></p>
<ul>
<li>如果URL是HTTPS协议，在TCP连接建立后，还需要进行TLS&#x2F;SSL握手以建立安全信道：<ol>
<li><strong>Client Hello:</strong> 浏览器发送支持的加密套件、TLS版本、一个随机数等信息。</li>
<li><strong>Server Hello:</strong> 服务器选择一个加密套件、TLS版本，返回自己的数字证书和一个随机数。</li>
<li><strong>Certificate Verification:</strong> 浏览器验证服务器证书的有效性（是否由信任的CA签发、是否过期、域名是否匹配）。</li>
<li><strong>Key Exchange:</strong> 浏览器生成另一个随机数（预主密钥），用服务器证书中的公钥加密后发送给服务器。</li>
<li><strong>Session Keys Generated:</strong> 双方根据三个随机数和协商的算法，生成对称的会话密钥，用于后续通信加密。</li>
<li><strong>Finished:</strong> 双方互相发送加密的“Finished”消息，确认握手完成。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>发送HTTP(S)请求:</strong></p>
<ul>
<li>TCP（和TLS）连接建立后，浏览器构造并发送一个HTTP请求报文。</li>
<li>报文包含：请求行（方法GET&#x2F;POST等，路径，HTTP版本）、请求头（<code>Host</code>, <code>User-Agent</code>, <code>Accept</code>, <code>Cookie</code>, <code>Referer</code>, 以及前面提到的缓存验证头<code>If-Modified-Since</code>&#x2F;<code>If-None-Match</code>等）、以及可选的请求体（POST请求的数据）。</li>
</ul>
</li>
<li><p><strong>服务器处理请求并响应:</strong></p>
<ul>
<li>服务器（如Nginx, Apache）接收到请求。</li>
<li>Web服务器可能将请求转交给应用服务器（如Node.js, Tomcat, PHP）。</li>
<li>后端代码执行，可能查询数据库、处理业务逻辑。</li>
<li>服务器生成一个HTTP响应报文。</li>
<li>报文包含：状态行（HTTP版本，状态码如 <code>200 OK</code>, <code>304 Not Modified</code>, <code>404 Not Found</code>等）、响应头（<code>Content-Type</code>, <code>Content-Length</code>, <code>Set-Cookie</code>, 以及缓存控制头<code>Cache-Control</code>, <code>ETag</code>, <code>Last-Modified</code>等）、以及响应体（通常是HTML内容，但也可能是CSS, JS, 图片等）。</li>
</ul>
</li>
<li><p><strong>浏览器接收并处理响应:</strong></p>
<ul>
<li>浏览器接收HTTP响应。</li>
<li><strong>检查状态码:</strong> 如果是<code>304 Not Modified</code>，浏览器直接从缓存加载资源。如果是<code>200 OK</code>等成功状态码，则处理响应体。如果是重定向（3xx），浏览器会根据<code>Location</code>头发出新的请求。如果是错误（4xx, 5xx），可能会显示错误页面。</li>
<li>处理响应体 (以HTML为例):<ul>
<li>浏览器根据响应头中的<code>Content-Type</code>（例如 <code>text/html</code>）来决定如何处理响应体。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>渲染页面:</strong> 这是浏览器内部非常复杂的过程，大致分为：</p>
<ul>
<li><strong>解析HTML (Parsing HTML):</strong> 浏览器将接收到的HTML文本解析成<strong>DOM (Document Object Model)</strong> 树。这是一个基于节点的对象表示，反映了HTML的结构。HTML解析器是<strong>渐进式</strong>的，边接收边解析。</li>
<li><strong>解析CSS (Parsing CSS):</strong> 在解析HTML时，如果遇到<code>&lt;link&gt;</code>标签引入外部CSS文件，或<code>&lt;style&gt;</code>标签内的CSS，浏览器会异步请求并解析CSS，构建<strong>CSSOM (CSS Object Model)</strong> 树。CSSOM表示了所有元素的样式信息。</li>
<li><strong>构建渲染树 (Render Tree Construction):</strong> 浏览器将DOM树和CSSOM树结合起来，生成<strong>渲染树 (Render Tree)</strong>。渲染树只包含<strong>需要显示</strong>的节点（例如<code>display: none</code>的节点会被排除）以及它们的计算后样式。</li>
<li><strong>布局 (Layout &#x2F; Reflow):</strong> 浏览器根据渲染树和视口（viewport）大小，计算每个节点在屏幕上的<strong>确切位置和尺寸</strong>。这个过程称为布局或回流（Reflow）。布局是一个<strong>全局</strong>过程，一个节点的改变可能影响其他节点。</li>
<li><strong>绘制 (Painting &#x2F; Repaint):</strong> 浏览器根据渲染树和布局信息，将每个节点绘制成屏幕上的<strong>实际像素</strong>。绘制通常发生在多个图层（Layers）上。这个过程称为绘制或重绘（Repaint）。</li>
<li><strong>合成 (Compositing):</strong> 浏览器将绘制好的各个图层按照正确的顺序（考虑<code>z-index</code>等）合并、显示在屏幕上。对于有特定属性（如<code>transform</code>, <code>opacity</code>）的元素，浏览器可能会将其提升到单独的合成层（Compositor Layer），由GPU加速处理，这样它们的变换就不会触发整个页面的重绘或回流，性能更好。</li>
</ul>
</li>
<li><p><strong>JavaScript执行:</strong></p>
<ul>
<li>在HTML解析过程中，如果遇到<code>&lt;script&gt;</code>标签（没有<code>async</code>或<code>defer</code>属性），HTML解析会<strong>暂停</strong>，浏览器会请求（如果是外部脚本）、解析并执行JavaScript代码。</li>
<li>JavaScript代码可以<strong>修改DOM和CSSOM</strong>（例如 <code>document.getElementById().style.color = &#39;red&#39;</code> 或 <code>document.createElement()</code>)。这些修改可能会<strong>触发新的回流和重绘</strong>。</li>
<li><code>defer</code>属性会让脚本在HTML解析完成后、<code>DOMContentLoaded</code>事件触发前按顺序执行。</li>
<li><code>async</code>属性会让脚本异步下载并在下载完成后立即执行，不保证顺序，且可能在HTML解析未完成时执行。它们都不阻塞HTML解析。</li>
</ul>
</li>
<li><p><strong>页面加载完成:</strong></p>
<ul>
<li>当所有资源（HTML, CSS, JS, 图片等）加载完成，并且所有<code>defer</code>脚本执行完毕后，浏览器会触发<code>window</code>的<code>load</code>事件。此时，页面完全渲染完成。</li>
</ul>
</li>
</ol>
<h4 id="HTTP-vs-HTTPS-的区别："><a href="#HTTP-vs-HTTPS-的区别：" class="headerlink" title="HTTP vs. HTTPS 的区别："></a><strong>HTTP vs. HTTPS 的区别：</strong></h4><p>主要区别在于<strong>安全性</strong>：</p>
<ol>
<li><p>安全性:</p>
<ul>
<li><p><strong>HTTP (HyperText Transfer Protocol):</strong> 是<strong>明文传输</strong>协议。数据在网络上传输时不加密，容易被中间人窃听、篡改。</p>
</li>
<li><p>HTTPS (HyperText Transfer Protocol Secure):是在HTTP的基础上加入了SSL&#x2F;TLS加密层的安全协议。它提供了：</p>
<ul>
<li><strong>数据加密 (Confidentiality):</strong> 通信内容被加密，第三方无法直接读取。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><strong>数据完整性 (Integrity):</strong> 通过校验机制确保数据在传输过程中未被篡改。<ul>
<li><strong>身份认证 (Authentication):</strong> 通过服务器证书验证网站的真实身份，防止钓鱼网站。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>端口号:</p>
<ul>
<li>HTTP默认使用<strong>80</strong>端口。</li>
<li>HTTPS默认使用<strong>443</strong>端口。</li>
</ul>
</li>
<li><p>连接过程:</p>
<ul>
<li>HTTPS在建立TCP连接后，需要进行额外的<strong>TLS&#x2F;SSL握手</strong>过程来协商加密密钥和验证服务器身份。HTTP则不需要。</li>
</ul>
</li>
<li><p>证书:</p>
<ul>
<li>HTTPS需要向**证书颁发机构（CA）**申请数字证书来证明服务器身份。HTTP不需要。</li>
</ul>
</li>
<li><p>性能:</p>
<ul>
<li>理论上，HTTPS由于涉及加解密和握手过程，会比HTTP稍微慢一点，并消耗更多的服务器资源。但现代CPU对加解密优化得很好，并且可以通过HTTP&#x2F;2等协议优化，这种性能差异通常不显著，安全性带来的好处远大于这点开销。</li>
</ul>
</li>
</ol>
<h4 id="请你说说实现元素水平居中和垂直居中的常用方法有哪些？"><a href="#请你说说实现元素水平居中和垂直居中的常用方法有哪些？" class="headerlink" title="请你说说实现元素水平居中和垂直居中的常用方法有哪些？"></a><strong>请你说说实现元素水平居中和垂直居中的常用方法有哪些？</strong></h4><p><strong>1. Flexbox (弹性布局 - 最常用、最推荐)</strong></p>
<ul>
<li><p><strong>适用场景:</strong> 对块级或行内块级子元素进行居中，无论是否知道子元素尺寸。</p>
</li>
<li><p>方法:在父容器上设置：CSS</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/* 水平居中 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: center;    <span class="comment">/* 垂直居中 */</span></span><br><span class="line">  <span class="comment">/* 可能需要设置父容器高度，例如: min-height: 100vh; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点:</strong> 代码简洁、语义化、功能强大，兼容性好。</p>
</li>
</ul>
<p><strong>2. Grid (网格布局 - 功能强大)</strong></p>
<ul>
<li><p><strong>适用场景:</strong> 类似于Flexbox，特别适合更复杂的二维布局，居中只是其能力之一。</p>
<p>使用 <code>justify-content</code> 和 <code>align-content</code> - 针对网格本身在容器中的对齐:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/* 水平居中网格项(如果只有一个)或整个网格 */</span></span><br><span class="line">  <span class="attribute">align-content</span>: center;   <span class="comment">/* 垂直居中网格项(如果只有一个)或整个网格 */</span></span><br><span class="line">  <span class="comment">/* 可能需要设置父容器高度 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>优点:</strong> 非常强大，尤其适合二维布局，代码同样简洁。</p>
</li>
</ul>

    </div>
  </article>

  <article class="post-detail">
    <h1 class="post-title"><a href="/">八股积累-01</a></h1>
    <ul class="post-meta">
  <li><i class="fa fa-user"></i> Author Xiaoyi Hao</li>
  <li><i class="fa fa-calendar"></i> Date Apr 13</li>
  <li><i class="fa fa-folder"></i> Categories
  
    no_categories
  
  </li>
</ul>
    <div class="post-content">
      <h4 id="八股积累01"><a href="#八股积累01" class="headerlink" title="八股积累01:"></a><strong>八股积累01:</strong></h4><h5 id="1-script标签的async和defer属性"><a href="#1-script标签的async和defer属性" class="headerlink" title="1.script标签的async和defer属性"></a><strong>1.script标签的async和defer属性</strong></h5><p>“script标签的async和defer属性都用于<strong>优化JavaScript加载执行过程</strong>，但它们的行为有明显区别：</p>
<ul>
<li><strong>defer</strong>：脚本会并行下载，<strong>但会等到HTML解析完成后</strong>，DOMContentLoaded事件前执行，<strong>保持脚本的执行顺序</strong></li>
<li><strong>async</strong>：脚本会并行下载，下载完成后立即执行，<strong>不保证执行顺序</strong>，<strong>也不等待HTML解析完成</strong></li>
</ul>
<p>实际应用中，defer适合那些需要访问完整DOM或有依赖关系的脚本，async更适合独立的第三方脚本，如分析工具等。”</p>
<h5 id="2-同步和异步操作"><a href="#2-同步和异步操作" class="headerlink" title="2.同步和异步操作"></a><strong>2.同步和异步操作</strong></h5><p><strong>在JavaScript中，同步操作按顺序执行，每个操作完成后才执行下一个，这可能导致长时间操作阻塞界面。而异步操作允许代码继续执行而不等待操作完成，结果通过回调函数、Promise或async&#x2F;await处理。</strong></p>
<p><strong>常见的异步操作包括：AJAX请求、setTimeout&#x2F;setInterval、事件监听和文件操作等。</strong></p>
<h5 id="3-对于DOM的操作方法"><a href="#3-对于DOM的操作方法" class="headerlink" title="3.对于DOM的操作方法"></a><strong>3.对于DOM的操作方法</strong></h5><ul>
<li>元素选择：getElementById、querySelector、querySelector<strong>All</strong>等</li>
<li>元素创建：create<strong>Element</strong>、createTextNode</li>
<li>元素修改：appendChild、removeChild、replaceChild、insertBefore</li>
<li>属性操作：<strong>get</strong>Attribute、setAttribute、<strong>remove</strong>Attribute</li>
<li>样式操作：element.style或classList.add&#x2F;remove&#x2F;toggle</li>
<li>内容操作：innerHTML、textContent、innerText</li>
</ul>
<h5 id="4-块级元素和行内元素"><a href="#4-块级元素和行内元素" class="headerlink" title="4.块级元素和行内元素"></a><strong>4.块级元素和行内元素</strong></h5><p><strong>块级元素特点：</strong></p>
<ul>
<li><strong>独占一行，默认宽度为父容器的100%</strong></li>
<li><strong>可以设置width、height、margin和padding</strong></li>
<li><strong>典型的块级元素有：div、p、h1-h6、ul、ol、li、table、form等</strong></li>
</ul>
<p><strong>行内元素特点：</strong></p>
<ul>
<li><strong>不会独占一行，多个行内元素会在同一行显示</strong></li>
<li><strong>宽高由内容决定，设置width和height无效</strong></li>
<li>margin和padding只在水平方向有效</li>
<li><strong>代表元素：span、a、strong、em、img、input等</strong></li>
</ul>
<h5 id="5-盒模型"><a href="#5-盒模型" class="headerlink" title="5.盒模型"></a><strong>5.盒模型</strong></h5><p><strong>标准盒模型(content-box)<strong>和</strong>IE盒模型(border-box)<strong>是CSS中</strong>两种不同的盒模型</strong>。</p>
<p>**标准盒模型下，元素的宽高仅包括内容区(content)，不包括padding、border和margin。**即：</p>
<ul>
<li>实际宽度 &#x3D; width + padding-left + padding-right + border-left + border-right</li>
<li>实际高度 &#x3D; height + padding-top + padding-bottom + border-top + border-bottom</li>
</ul>
<p>**而IE盒模型(border-box)中，元素的宽高包括内容区、padding和border，但不包括margin。**即：</p>
<ul>
<li>width &#x3D; 内容宽度 + padding-left + padding-right + border-left + border-right</li>
<li>height &#x3D; 内容高度 + padding-top + padding-bottom + border-top + border-bottom</li>
</ul>
<h5 id="6-行内元素可以设置宽高吗？怎么设置"><a href="#6-行内元素可以设置宽高吗？怎么设置" class="headerlink" title="6.行内元素可以设置宽高吗？怎么设置"></a><strong>6.行内元素可以设置宽高吗？怎么设置</strong></h5><p><strong>行内元素(inline)默认情况下不能设置宽高，其尺寸由内容决定</strong>。但有两种方式可以让行内元素接受宽高设置：</p>
<p><strong>1.将行内元素转换为块级或行内块元素：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block; <span class="comment">/* 或 inline-block */</span></span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.将行内元素设置为flex项目：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际开发中，我更倾向于使用<code>display: inline-block</code>，因为它既可以设置宽高，又不会破坏元素的行内特性，不会强制换行。</p>
<h5 id="7-讲讲position"><a href="#7-讲讲position" class="headerlink" title="7.讲讲position"></a><strong>7.讲讲position</strong></h5><p>CSS的position属性定义元素的定位方式，主要有五个值：</p>
<ol>
<li><code>static</code>(默认值)：元素按照正常文档流进行布局，<strong>top、right、bottom、left和z-index属性无效</strong>。</li>
<li><code>relative</code>：<strong>元素相对于其正常位置进行定位，不脱离文档流，不影响其他元素的布局。</strong></li>
<li><code>absolute</code>：<strong>元素脱离文档流，相对于最近的非static定位祖先元素进行定位。如果没有这样的祖先元素，则相对于初始包含块(通常是viewport)。</strong></li>
<li><code>fixed</code>：<strong>元素脱离文档流，相对于浏览器视口(viewport)进行定位，即使页面滚动也保持固定位置</strong>。</li>
<li><code>sticky</code>：<strong>元素在滚动到特定位置前相当于relative，之后表现为fixed。是relative和fixed的混合</strong>。</li>
</ol>
<h5 id="8-元素水平居中的方式"><a href="#8-元素水平居中的方式" class="headerlink" title="8.元素水平居中的方式"></a><strong>8.元素水平居中的方式</strong></h5><p><strong>对于行内元素或行内块元素：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于固定宽度的块级元素</strong>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用flexbox：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用grid：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">justify-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-讲讲flex"><a href="#9-讲讲flex" class="headerlink" title="9.讲讲flex"></a><strong>9.讲讲flex</strong></h5><p>Flexbox(弹性盒子)是CSS3中的一种布局模式，专为创建更加灵活的页面布局而设计。主要特点：</p>
<p>核心概念：</p>
<ul>
<li>Flex容器(container)：设置<code>display: flex</code>的元素</li>
<li>Flex项目(items)：Flex容器的子元素</li>
<li>主轴(main axis)和交叉轴(cross axis)</li>
</ul>
<p>容器属性：</p>
<ul>
<li><code>flex-direction</code>: 决定主轴方向(row&#x2F;column)</li>
<li><code>flex-wrap</code>: 控制项目是否换行</li>
<li><code>justify-content</code>: 主轴上的对齐方式</li>
<li><code>align-items</code>: 交叉轴上的对齐方式</li>
<li><code>align-content</code>: 多行对齐方式</li>
</ul>
<h5 id="10-var-a-1-function-a-console-log-a-输出？"><a href="#10-var-a-1-function-a-console-log-a-输出？" class="headerlink" title="10. var a&#x3D;1;function a(){} console.log(a)输出？"></a><strong>10. var a&#x3D;1;function a(){} console.log(a)输出？</strong></h5><p>这段代码输出的结果是<code>1</code>。</p>
<p>这涉及到JavaScript中的变量提升和函数声明提升的机制：</p>
<ol>
<li>函数声明<code>function a()&#123;&#125;</code>会被整体提升到作用域顶部</li>
<li>变量声明<code>var a</code>也会被提升，但赋值不会</li>
<li>同名的函数声明和变量声明，函数声明优先级更高</li>
<li>执行到<code>var a=1</code>时，变量a被赋值为1，覆盖了之前的函数引用</li>
</ol>
<p>代码执行顺序等同于：</p>
<p>javascript</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125; <span class="comment">// 函数声明提升</span></span><br><span class="line"><span class="keyword">var</span> a;         <span class="comment">// 变量声明提升（此时a已经是函数）</span></span><br><span class="line">a = <span class="number">1</span>;         <span class="comment">// 赋值操作，a变成了数字1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出1</span></span><br></pre></td></tr></table></figure>

<p>这个问题考察了JavaScript中函数声明和变量声明的提升机制以及它们的优先级关系。理解这些规则对于避免代码中的潜在问题很重要。</p>
<h5 id="11-判断数据类型的方法-根据英文名字记忆"><a href="#11-判断数据类型的方法-根据英文名字记忆" class="headerlink" title="11. 判断数据类型的方法(根据英文名字记忆)"></a><strong>11. 判断数据类型的方法(根据英文名字记忆)</strong></h5><p><strong>1.typeof运算符</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>;           <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;hello&quot;</span>;      <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>;         <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>;    <span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>();     <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42n</span>;          <span class="comment">// &quot;bigint&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;;           <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> [];           <span class="comment">// &quot;object&quot; (注意数组返回&quot;object&quot;)</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>;         <span class="comment">// &quot;object&quot; (这是一个历史遗留bug)</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;; <span class="comment">// &quot;function&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.instanceof运算符</strong>：检测<strong>对象是否是某个构造函数的实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="title class_">Array</span>;  <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>3.Object.prototype.toString.call()</strong>：最准确的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">42</span>);        <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&quot;hello&quot;</span>);   <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>);      <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>); <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>);      <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;);        <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]);        <span class="comment">// &quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>4.Array.isArray()</strong>：专們用于检测数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([]);  <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;&#125;);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h5 id="12-闭包的实际应用"><a href="#12-闭包的实际应用" class="headerlink" title="12.闭包的实际应用"></a><strong>12.闭包的实际应用</strong></h5><p>闭包是指一个函数能够访问并记住其词法作用域，即使该函数在其词法作用域之外执行。实际应用包括：</p>
<p><strong>1.数据私有化&#x2F;封装</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;  <span class="comment">// 私有变量</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; count++; &#125;,</span><br><span class="line">        <span class="attr">decrement</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; count--; &#125;,</span><br><span class="line">        <span class="attr">getCount</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> count; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">createCounter</span>();</span><br><span class="line">counter.<span class="title function_">increment</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter.<span class="title function_">getCount</span>()); <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 无法直接访问count变量</span></span><br></pre></td></tr></table></figure>

<p><strong>2.模块模式</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> calculator = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 私有变量和函数</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x</span>) &#123; result += x; &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">subtract</span>(<span class="params">x</span>) &#123; result -= x; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 公共API</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        add,</span><br><span class="line">        subtract,</span><br><span class="line">        <span class="attr">getResult</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">calculator.<span class="title function_">add</span>(<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(calculator.<span class="title function_">getResult</span>()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p><strong>3.函数工厂</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createMultiplier</span>(<span class="params">multiplier</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x * multiplier;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> double = <span class="title function_">createMultiplier</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> triple = <span class="title function_">createMultiplier</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">double</span>(<span class="number">5</span>)); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">triple</span>(<span class="number">5</span>)); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p><strong>4.setTimeout中保存循环变量</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 问题代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i), <span class="number">100</span>); <span class="comment">// 输出：3,3,3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用闭包解决</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    (<span class="keyword">function</span>(<span class="params">index</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(index), <span class="number">100</span>); <span class="comment">// 输出：0,1,2</span></span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代解决方案：使用let替代var</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i), <span class="number">100</span>); <span class="comment">// 输出：0,1,2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5.事件处理和回调</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupButtonActions</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> buttons = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    buttons.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">button, index</span>) &#123;</span><br><span class="line">        button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 闭包可以访问index和button</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Button <span class="subst">$&#123;index&#125;</span> clicked`</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="13-写判读值相同isEqual-a-b-函数，a和b的数据类型不一定一样"><a href="#13-写判读值相同isEqual-a-b-函数，a和b的数据类型不一定一样" class="headerlink" title="13.写判读值相同isEqual(a,b)函数，a和b的数据类型不一定一样"></a><strong>13.写判读值相同isEqual(a,b)函数，a和b的数据类型不一定一样</strong></h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isEqual</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.判断基本类型或引用相同</span></span><br><span class="line">  <span class="keyword">if</span> (a === b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.如果其中一个是null或不是对象，且已经不相等，返回false</span></span><br><span class="line">  <span class="keyword">if</span> (a === <span class="literal">null</span> || b === <span class="literal">null</span> || <span class="keyword">typeof</span> a !== <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> b !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.处理日期对象</span></span><br><span class="line">  <span class="keyword">if</span> (a <span class="keyword">instanceof</span> <span class="title class_">Date</span> &amp;&amp; b <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">getTime</span>() === b.<span class="title function_">getTime</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4.处理正则表达式</span></span><br><span class="line">  <span class="keyword">if</span> (a <span class="keyword">instanceof</span> <span class="title class_">RegExp</span> &amp;&amp; b <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="title function_">toString</span>() === b.<span class="title function_">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.检查是否为数组</span></span><br><span class="line">  <span class="keyword">const</span> isArrayA = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(a);</span><br><span class="line">  <span class="keyword">const</span> isArrayB = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(b);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个是数组一个不是，返回false</span></span><br><span class="line">  <span class="keyword">if</span> (isArrayA !== isArrayB) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理数组</span></span><br><span class="line">  <span class="keyword">if</span> (isArrayA &amp;&amp; isArrayB) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="property">length</span> !== b.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isEqual</span>(a[i], b[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 6.处理普通对象</span></span><br><span class="line">  <span class="keyword">const</span> keysA = <span class="title class_">Object</span>.<span class="title function_">keys</span>(a);</span><br><span class="line">  <span class="keyword">const</span> keysB = <span class="title class_">Object</span>.<span class="title function_">keys</span>(b);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (keysA.<span class="property">length</span> !== keysB.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保b中包含a的所有键，并且对应值相等</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keysA) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!keysB.<span class="title function_">includes</span>(key) || !<span class="title function_">isEqual</span>(a[key], b[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CSS-布局-Layout-vs-定位-Positioning-属性对比"><a href="#CSS-布局-Layout-vs-定位-Positioning-属性对比" class="headerlink" title="CSS 布局 (Layout) vs 定位 (Positioning) 属性对比"></a><strong>CSS 布局 (Layout) vs 定位 (Positioning) 属性对比</strong></h4><table>
<thead>
<tr>
<th><strong>概念分类</strong></th>
<th><strong>属性 (Property)</strong></th>
<th><strong>主要作用 (Main Purpose)</strong></th>
<th><strong>关键值&#x2F;说明 (Key Values&#x2F;Notes)</strong></th>
<th><strong>对文档流影响 (Impact on Document Flow)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>布局 (Layout)</strong></td>
<td><code>display</code></td>
<td>定义元素的基本框类型和布局方式（块级、内联、弹性、网格等）</td>
<td><code>block</code>, <code>inline</code>, <code>inline-block</code>, <code>flex</code>, <code>grid</code>, <code>none</code>, <code>table</code> 等</td>
<td><strong>根本性影响</strong>。决定元素如何参与或不参与文档流，是否独占一行等。</td>
</tr>
<tr>
<td></td>
<td><code>width</code>, <code>height</code> (及 <code>min/max</code> 变体)</td>
<td>设置元素的尺寸</td>
<td>像素 (<code>px</code>), 百分比 (<code>%</code>), <code>auto</code>, <code>vw</code>&#x2F;<code>vh</code> 等</td>
<td><strong>影响</strong>。决定元素在流中所占据的空间大小。</td>
</tr>
<tr>
<td></td>
<td><code>margin</code></td>
<td>设置元素<strong>外</strong>边距，控制元素之间的间距</td>
<td>可以是正负值，像素，百分比等。<code>auto</code> 可用于块级元素水平居中。</td>
<td><strong>影响</strong>。改变元素周围的空间，从而影响相邻元素在流中的位置。</td>
</tr>
<tr>
<td></td>
<td><code>padding</code></td>
<td>设置元素<strong>内</strong>边距，控制内容与边框的距离</td>
<td>通常是正值，像素，百分比等。</td>
<td><strong>影响</strong>。改变元素内部空间，可能影响元素（在 <code>content-box</code>下）的总尺寸，但不改变其在流中的基本性质。</td>
</tr>
<tr>
<td></td>
<td><code>box-sizing</code></td>
<td>定义 <code>width</code> 和 <code>height</code> 如何计算（是否包含 padding 和 border）</td>
<td><code>content-box</code> (默认), <code>border-box</code></td>
<td><strong>影响布局计算</strong>，但不直接改变元素的流行为（块级还是内联等）。</td>
</tr>
<tr>
<td></td>
<td><code>float</code></td>
<td>使元素脱离正常流，向左或右移动，允许文本或其他内联元素环绕</td>
<td><code>left</code>, <code>right</code>, <code>none</code></td>
<td><strong>部分脱离</strong>。元素本身仍在布局中（影响父容器高度等），但其位置脱离常规流，后续非 <code>clear</code> 元素会环绕它。</td>
</tr>
<tr>
<td></td>
<td><code>clear</code></td>
<td>指定元素旁边是否允许浮动元素</td>
<td><code>left</code>, <code>right</code>, <code>both</code>, <code>none</code></td>
<td><strong>影响</strong>。强制元素移动到浮动元素的下方，恢复正常流的部分顺序。</td>
</tr>
<tr>
<td></td>
<td>Flexbox 属性 (如 <code>flex-direction</code>, <code>justify-content</code>, <code>align-items</code>)</td>
<td>（用于 <code>display: flex</code> 容器）控制弹性项目在容器内的排列、对齐和分布</td>
<td>多种值，用于控制主轴、交叉轴对齐，换行等</td>
<td><strong>定义容器内项目的新文档流</strong>（弹性流）。</td>
</tr>
<tr>
<td></td>
<td>Grid 属性 (如 <code>grid-template-columns</code>, <code>grid-template-rows</code>, <code>gap</code>)</td>
<td>（用于 <code>display: grid</code> 容器）定义二维网格结构，并将项目放入网格单元</td>
<td>定义列宽、行高、区域、间距等</td>
<td><strong>定义容器内项目的新文档流</strong>（网格流）。</td>
</tr>
<tr>
<td></td>
<td><code>overflow</code></td>
<td>控制内容超出元素框时的处理方式</td>
<td><code>visible</code>, <code>hidden</code>, <code>scroll</code>, <code>auto</code></td>
<td><strong>主要影响内容呈现</strong>，一般不改变元素在流中的位置和大小（除非 <code>visible</code> 导致内容溢出影响后续元素）。</td>
</tr>
<tr>
<td></td>
<td><code>vertical-align</code></td>
<td>设置行内元素或表格单元格的垂直对齐方式</td>
<td><code>baseline</code>, <code>top</code>, <code>middle</code>, <code>bottom</code>, 长度值等</td>
<td><strong>影响</strong>。调整元素在<strong>行框 (line box)</strong> 或表格单元格内的垂直位置，属于流内微调。</td>
</tr>
<tr>
<td><strong>定位 (Positioning)</strong></td>
<td><code>position</code></td>
<td><strong>定义元素的定位机制</strong></td>
<td><code>static</code> (默认), <code>relative</code>, <code>absolute</code>, <code>fixed</code>, <code>sticky</code></td>
<td><strong>关键性影响</strong>。<code>relative</code> 不脱离但可偏移；<code>absolute</code>&#x2F;<code>fixed</code> 完全脱离；<code>sticky</code> 条件性脱离&#x2F;固定。</td>
</tr>
<tr>
<td></td>
<td><code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code></td>
<td>（当 <code>position</code> 非 <code>static</code> 时）<strong>设置定位元素相对于其参照物的偏移量</strong></td>
<td>长度值 (<code>px</code>, <code>%</code> 等), <code>auto</code></td>
<td><strong>不直接影响</strong>其他元素的常规文档流布局，仅移动该元素本身。脱离流的元素不再占据原始空间。</td>
</tr>
<tr>
<td></td>
<td><code>z-index</code></td>
<td>（当 <code>position</code> 非 <code>static</code> 时）<strong>设置定位元素的堆叠顺序（前后层次）</strong></td>
<td>整数 (可正可负), <code>auto</code></td>
<td><strong>不影响</strong>文档流布局，仅影响元素在 Z 轴（视觉前后）上的覆盖关系。</td>
</tr>
</tbody></table>
<p><strong>记忆小结：</strong></p>
<ul>
<li><strong>布局 (Layout)</strong> 属性更像是“规划师”，负责安排大家（元素）怎么站队、占多大地儿、彼此隔多远。它们主要在<strong>文档流内部</strong>工作，或者创建新的流上下文（Flex&#x2F;Grid）。</li>
<li><strong>定位 (Positioning)</strong> 属性更像是“调度员”，可以把某个特定的人（元素）叫出来，让他站到<strong>指定的位置</strong>，有时甚至可以让他“飞起来”（脱离地面&#x2F;文档流），或者叠在别人身上。<code>position</code> 是开启定位能力的总开关，<code>top/right/bottom/left</code> 是具体的坐标指令，<code>z-index</code> 是处理重叠时的前后顺序。</li>
</ul>
<h4 id="输入一个url会发生什么，尽量具体。"><a href="#输入一个url会发生什么，尽量具体。" class="headerlink" title="输入一个url会发生什么，尽量具体。"></a><strong>输入一个url会发生什么，尽量具体。</strong></h4><p><strong>我：</strong> 这个过程非常复杂，涉及浏览器、操作系统、网络协议等多个层面。我尝试尽可能详细地描述一下主要步骤：</p>
<ol>
<li><strong>用户输入与解析 (Input &amp; Parsing):</strong> 用户在浏览器地址栏输入 URL (Uniform Resource Locator)，比如 <code>https://www.example.com/path?query=1</code>。浏览器会解析这个 URL，识别出协议 (<code>https</code>)、域名 (<code>www.example.com</code>)、路径 (<code>/path</code>)、查询参数 (<code>?query=1</code>) 等。浏览器可能还会进行一些预处理，比如自动补全 <code>https://</code> 或者处理特殊字符。</li>
<li><strong>DNS 查询 (Domain Name System Lookup):</strong> 由于网络通信是基于 IP 地址的，浏览器需要将域名转换为对应的服务器 IP 地址。<ul>
<li><strong>浏览器缓存:</strong> 检查浏览器自身的 DNS 缓存。</li>
<li><strong>操作系统缓存:</strong> 检查操作系统的 DNS 缓存 (如 <code>hosts</code> 文件)。</li>
<li><strong>路由器缓存:</strong> 检查本地路由器的 DNS 缓存。</li>
<li><strong>ISP DNS 服务器:</strong> 向配置的本地 ISP (互联网服务提供商) 的 DNS 服务器发起递归查询请求。</li>
<li><strong>根域名服务器 -&gt; TLD 服务器 -&gt; 权威 DNS 服务器:</strong> ISP DNS 服务器会从根服务器开始，逐级查询顶级域名 (TLD, 如 <code>.com</code>) 服务器，最终找到负责 <code>example.com</code> 域名的权威 DNS 服务器，获取到 IP 地址。</li>
<li><strong>返回与缓存:</strong> 权威 DNS 服务器将 IP 地址返回给 ISP DNS 服务器，后者再返回给操作系统和浏览器，并进行缓存。</li>
</ul>
</li>
<li><strong>建立 TCP 连接 (TCP Connection Setup):</strong> 浏览器获取到 IP 地址后，需要与目标服务器建立 TCP 连接。这通常通过<strong>三次握手</strong>完成：<ul>
<li><strong>SYN:</strong> 浏览器（客户端）向服务器发送一个 SYN (Synchronize Sequence Numbers) 包，表示请求建立连接。</li>
<li><strong>SYN-ACK:</strong> 服务器收到 SYN 包后，如果同意连接，会回复一个 SYN-ACK (Synchronize-Acknowledgement) 包，表示确认收到请求并也请求建立连接。</li>
<li><strong>ACK:</strong> 浏览器收到 SYN-ACK 包后，再发送一个 ACK (Acknowledgement) 包给服务器，表示确认收到服务器的确认。至此，TCP 连接建立成功。</li>
</ul>
</li>
<li><strong>TLS&#x2F;SSL 握手 (If HTTPS):</strong> 如果 URL 是 <code>https</code> 协议，在 TCP 连接建立后，还需要进行 TLS (Transport Layer Security) &#x2F; SSL (Secure Sockets Layer) 握手，以建立加密信道：<ul>
<li>客户端发送 ClientHello (支持的加密套件、协议版本等)。</li>
<li>服务器回应 ServerHello (选定的加密套件、协议版本)，并发送其数字证书。</li>
<li>客户端验证证书的有效性（是否由受信任的 CA 颁发、是否过期、域名是否匹配等）。</li>
<li>（可能）客户端和服务器交换密钥信息（如使用 Diffie-Hellman 算法协商会话密钥）。</li>
<li>双方都生成会话密钥，并确认握手完成。之后的所有 HTTP 数据都将通过这个加密通道传输。</li>
</ul>
</li>
<li><strong>发送 HTTP(S) 请求 (Sending HTTP(S) Request):</strong> 浏览器构建一个 HTTP 请求报文，通过建立好的 TCP (和 TLS) 连接发送给服务器。请求报文通常包含：<ul>
<li><strong>请求行:</strong> 请求方法 (GET, POST等)、请求的资源路径 (<code>/path?query=1</code>)、HTTP 协议版本。</li>
<li><strong>请求头 (Headers):</strong> 包含各种附加信息，如 <code>Host</code> (目标域名)、<code>User-Agent</code> (浏览器标识)、<code>Accept</code> (可接受的内容类型)、<code>Cookie</code> (携带之前服务器设置的 Cookie)、<code>Connection: keep-alive</code> (建议保持 TCP 连接) 等。</li>
<li><strong>请求体 (Body):</strong> 对于 POST 请求等，会包含需要提交的数据。</li>
</ul>
</li>
<li><strong>服务器处理请求与响应 (Server Processing &amp; Response):</strong><ul>
<li>Web 服务器 (如 Nginx, Apache) 接收到请求。</li>
<li>根据请求路径和配置，可能将请求转发给后端应用服务器 (如 Node.js, Tomcat, PHP-FPM)。</li>
<li>后端应用处理业务逻辑，可能涉及数据库查询、调用其他服务等。</li>
<li>服务器构建一个 HTTP 响应报文，包含：<ul>
<li><strong>状态行:</strong> HTTP 协议版本、状态码 (如 <code>200 OK</code>, <code>404 Not Found</code>, <code>301 Moved Permanently</code>)、状态描述。</li>
<li><strong>响应头 (Headers):</strong> 如 <code>Content-Type</code> (响应体内容类型，如 <code>text/html</code>)、<code>Content-Length</code> (响应体大小)、<code>Set-Cookie</code> (要求浏览器设置 Cookie)、<code>Cache-Control</code> (缓存策略) 等。</li>
<li><strong>响应体 (Body):</strong> 实际的资源内容，如 HTML 文档、JSON 数据、图片等。</li>
</ul>
</li>
<li>服务器将响应报文通过 TCP 连接发送回浏览器。</li>
</ul>
</li>
<li><strong>浏览器接收与处理响应 (Browser Receiving &amp; Processing):</strong><ul>
<li>浏览器接收 HTTP 响应。</li>
<li><strong>解析 HTML:</strong> 如果响应类型是 <code>text/html</code>，浏览器开始解析 HTML 文档，构建 <strong>DOM (Document Object Model) 树</strong>。</li>
<li><strong>请求其他资源:</strong> 在解析 HTML 时，如果遇到外部资源引用（如 CSS 文件、JavaScript 文件、图片、字体），浏览器会<strong>并行或串行地</strong>发起新的 HTTP 请求去获取这些资源（过程类似步骤 2-6，但可能复用现有 TCP 连接 - HTTP Keep-Alive&#x2F;HTTP&#x2F;2 Multiplexing）。</li>
<li><strong>解析 CSS:</strong> 浏览器解析 CSS 文件（外部或内联样式），构建 <strong>CSSOM (CSS Object Model) 树</strong>。</li>
<li><strong>构建渲染树 (Render Tree):</strong> 结合 DOM 树和 CSSOM 树，创建渲染树。渲染树只包含需要显示的节点及其样式信息（<code>display: none</code> 的节点不会包含在内）。</li>
<li><strong>布局 (Layout &#x2F; Reflow):</strong> 根据渲染树，计算每个节点在屏幕上的精确位置和大小。</li>
<li><strong>绘制 (Paint &#x2F; Raster):</strong> 将渲染树的各个节点绘制成位图（像素）。浏览器可能会将页面分成多个层 (Layers) 来绘制。</li>
<li><strong>合成 (Composite):</strong> 将绘制好的各个层按照正确的顺序（考虑 <code>z-index</code> 等）合并到屏幕上显示。</li>
</ul>
</li>
<li><strong>JavaScript 执行:</strong><ul>
<li>在解析 HTML 时，如果遇到 <code>&lt;script&gt;</code> 标签（没有 <code>async</code> 或 <code>defer</code> 属性），HTML 解析会暂停，浏览器会下载（如果需要）并执行 JavaScript 代码。JS 代码可能会修改 DOM 或 CSSOM，这可能导致重新布局 (Reflow) 和重绘 (Repaint)。</li>
<li><code>defer</code> 的脚本会按顺序在 HTML 解析完成后、DOMContentLoaded 事件前执行。</li>
<li><code>async</code> 的脚本会在下载完成后立刻执行，可能在 HTML 解析完成前或后，执行顺序不确定，且会阻塞 HTML 解析。</li>
</ul>
</li>
<li><strong>页面加载完成与交互:</strong> 当所有资源（特别是初始渲染所需的）加载和处理完毕，页面显示完成。之后 JavaScript 可以响应用户的交互事件（点击、滚动、输入等）。</li>
</ol>
<h4 id="常见的tcp和udp协议"><a href="#常见的tcp和udp协议" class="headerlink" title="常见的tcp和udp协议"></a><strong>常见的tcp和udp协议</strong></h4><p><strong>我：</strong> 在 TCP&#x2F;IP 协议栈中，TCP 和 UDP 是传输层的两个主要协议。它们负责在网络中的应用程序之间传输数据。很多我们熟悉的上层应用协议都是基于它们构建的：</p>
<ul>
<li><strong>基于 TCP 的常见协议:</strong><ul>
<li><strong>HTTP&#x2F;HTTPS (HyperText Transfer Protocol &#x2F; Secure):</strong> 用于 Web 浏览器和 Web 服务器之间传输网页内容。</li>
<li><strong>FTP (File Transfer Protocol):</strong> 用于在网络上传输文件。</li>
<li><strong>SMTP (Simple Mail Transfer Protocol):</strong> 用于发送电子邮件。</li>
<li><strong>POP3 (Post Office Protocol version 3) &#x2F; IMAP (Internet Message Access Protocol):</strong> 用于接收电子邮件。</li>
<li><strong>SSH (Secure Shell):</strong> 用于安全的远程登录和执行命令。</li>
<li><strong>Telnet:</strong> 用于远程登录（不安全）。</li>
<li><strong>DNS:</strong> 虽然主要使用 UDP，但在需要传输大量数据（如区域传送）或要求可靠性时，也可以使用 TCP。</li>
</ul>
</li>
<li><strong>基于 UDP 的常见协议:</strong><ul>
<li><strong>DNS (Domain Name System):</strong> 主要用于域名到 IP 地址的快速查询。</li>
<li><strong>DHCP (Dynamic Host Configuration Protocol):</strong> 用于自动分配 IP 地址给网络中的设备。</li>
<li><strong>SNMP (Simple Network Management Protocol):</strong> 用于网络设备管理和监控。</li>
<li><strong>TFTP (Trivial File Transfer Protocol):</strong> 一个简化的文件传输协议。</li>
<li><strong>VoIP (Voice over IP):</strong> 很多实时语音通话应用使用 UDP 以减少延迟。</li>
<li><strong>在线游戏:</strong> 很多实时在线游戏的数据传输（如玩家位置同步）倾向于使用 UDP 以获得更快的响应。</li>
<li><strong>视频&#x2F;音频流:</strong> 一些实时流媒体协议（如 RTP）基于 UDP。</li>
<li><strong>NTP (Network Time Protocol):</strong> 用于同步网络中计算机的时间。</li>
<li><strong>QUIC (Quick UDP Internet Connections):</strong> HTTP&#x2F;3 使用的基础协议。</li>
</ul>
</li>
</ul>
<h4 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a><strong>tcp和udp的区别</strong></h4><p><strong>我：</strong> TCP (Transmission Control Protocol) 和 UDP (User Datagram Protocol) 是传输层的两个核心协议，它们的主要区别在于设计目标和提供的服务特性：</p>
<ol>
<li><strong>连接性:</strong><ul>
<li><strong>TCP:</strong> <strong>面向连接</strong>的协议。在数据传输前，必须先通过三次握手建立连接；传输结束后，需要通过四次挥手断开连接。</li>
<li><strong>UDP:</strong> <strong>无连接</strong>的协议。发送数据前不需要建立连接，直接将数据报 (Datagram) 发送出去。</li>
</ul>
</li>
<li><strong>可靠性:</strong><ul>
<li><strong>TCP:</strong> <strong>可靠的</strong>协议。通过序列号、确认应答 (ACK)、超时重传、数据校验等机制，确保数据能够<strong>有序、无差错、不丢失、不重复</strong>地到达目的地。</li>
<li><strong>UDP:</strong> <strong>不可靠的</strong>（或称“尽力而为”的）协议。不保证数据能否到达、是否按序到达、是否完整。它只负责将数据报发送出去，后续的可靠性需要应用层自己处理（如果需要的话）。</li>
</ul>
</li>
<li><strong>数据传输方式:</strong><ul>
<li><strong>TCP:</strong> 基于<strong>字节流 (Byte Stream)</strong>。数据没有明显的边界，像水流一样传输。接收方需要根据应用逻辑来划分数据。</li>
<li><strong>UDP:</strong> 基于<strong>数据报 (Datagram)</strong>。每个 UDP 包都是一个独立的消息单元，有明确的边界。接收方一次接收一个完整的报文。</li>
</ul>
</li>
<li><strong>效率与开销:</strong><ul>
<li><strong>TCP:</strong> 开销较大。因为需要维护连接状态、序列号、确认、重传、流量控制、拥塞控制等，头部信息也更复杂（至少 20 字节）。传输效率相对较低。</li>
<li><strong>UDP:</strong> 开销小。头部简单（固定 8 字节），没有复杂的控制机制。传输效率高，速度快。</li>
</ul>
</li>
<li><strong>流量控制与拥塞控制:</strong><ul>
<li><strong>TCP:</strong> 具备<strong>流量控制</strong>（使用滑动窗口，防止发送方过快地发送数据淹没接收方）和<strong>拥塞控制</strong>（根据网络状况动态调整发送速率，避免加剧网络拥堵）。</li>
<li><strong>UDP:</strong> <strong>没有</strong>流量控制和拥塞控制。发送方会以恒定速率（或应用层决定的速率）发送数据，不管接收方是否能处理，也不管网络是否拥堵。</li>
</ul>
</li>
<li><strong>应用场景:</strong><ul>
<li><strong>TCP:</strong> 适用于要求<strong>高可靠性、有序传输</strong>的应用。如网页浏览 (HTTP&#x2F;S)、文件传输 (FTP)、邮件 (SMTP&#x2F;POP3&#x2F;IMAP) 等。</li>
<li><strong>UDP:</strong> 适用于<strong>实时性要求高、能容忍少量丢包</strong>的应用，或者应用层自己实现了可靠性保障。如实时音视频通话 (VoIP)、在线游戏、DNS 查询、直播流、物联网数据上报等。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>特性</th>
<th>TCP (Transmission Control Protocol)</th>
<th>UDP (User Datagram Protocol)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>连接性</strong></td>
<td>面向连接 (Connection-oriented)</td>
<td>无连接 (Connectionless)</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>可靠 (Reliable)</td>
<td>不可靠 (Unreliable &#x2F; Best-effort)</td>
</tr>
<tr>
<td><strong>传输方式</strong></td>
<td>字节流 (Byte Stream)</td>
<td>数据报 (Datagram)</td>
</tr>
<tr>
<td><strong>顺序保证</strong></td>
<td>有序 (Ordered)</td>
<td>无序 (Unordered)</td>
</tr>
<tr>
<td><strong>流量控制</strong></td>
<td>有 (Flow Control)</td>
<td>无</td>
</tr>
<tr>
<td><strong>拥塞控制</strong></td>
<td>有 (Congestion Control)</td>
<td>无</td>
</tr>
<tr>
<td><strong>速度&#x2F;效率</strong></td>
<td>相对慢 &#x2F; 效率低</td>
<td>快 &#x2F; 效率高</td>
</tr>
<tr>
<td><strong>头部开销</strong></td>
<td>较大 (≥ 20 bytes)</td>
<td>小 (8 bytes)</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>Web, Email, File Transfer (可靠性优先)</td>
<td>Streaming, VoIP, DNS, Games (实时性优先)</td>
</tr>
</tbody></table>
<h4 id="你了解防抖和节流吗？它们的区别是什么？"><a href="#你了解防抖和节流吗？它们的区别是什么？" class="headerlink" title="你了解防抖和节流吗？它们的区别是什么？"></a><strong>你了解防抖和节流吗？它们的区别是什么？</strong></h4><p><strong>我：</strong> 是的，我了解防抖 (Debounce) 和节流 (Throttle)。它们都是用来优化高频触发事件（比如 <code>window.resize</code>, <code>scroll</code>, <code>input</code> 输入等）处理函数执行频率的技术，目的是提升性能和避免不必要的计算或请求。</p>
<ul>
<li><strong>防抖 (Debounce):</strong><ul>
<li><strong>策略:</strong> <strong>当事件持续触发时，并不会执行处理函数，只有当事件停止触发后，等待一个指定的时间间隔（delay），如果这个间隔内没有再次触发事件，才会执行一次处理函数。如果在这个间隔内事件又被触发了，则重新计时</strong>。</li>
<li><strong>好比:</strong> 电梯关门。只要有人在持续按开门按钮，电梯门就不会关。只有当最后一个人进来，并且在指定时间内（比如 3 秒）没有人再按开门按钮，电梯门才会关闭。</li>
<li>应用场景:<ul>
<li>搜索框输入建议（用户停止输入后再发请求）。</li>
<li>窗口大小调整后重新计算布局（只在用户调整完毕后计算一次）。</li>
<li>表单验证（用户停止输入后再进行校验）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>节流 (Throttle):</strong><ul>
<li><strong>策略:</strong> 确保一个函数在<strong>指定的时间间隔内最多只执行一次</strong>。无论事件触发多频繁，处理函数都会以固定的频率（如每 200 毫秒）执行一次。</li>
<li><strong>好比:</strong> 游戏技能冷却。按键按得再快，技能也只能在冷却时间结束后才能再次释放。或者像地铁的闸机，固定时间内只能通过一个人。</li>
<li>应用场景:<ul>
<li>页面滚动事件监听，用于判断是否到达某个位置（没必要每次滚动都计算，每隔几百毫秒检查一次即可）。</li>
<li>拖拽操作的实时更新（限制更新频率）。</li>
<li>高频点击按钮防止重复提交（比如限制 1 秒内只能提交一次）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>核心区别:</strong><ul>
<li><strong>防抖</strong>关注的是事件<strong>停止触发</strong>后的那一次执行，它会“取消”之前的等待，重新开始计时。适用于只需要最终结果的场景。</li>
<li><strong>节流</strong>关注的是在<strong>固定时间间隔内</strong>最多执行一次，它保证了函数执行的频率不会过高。适用于需要周期性响应的场景。</li>
</ul>
</li>
</ul>
<h4 id="你知道事件委托吗？能解释一下吗？"><a href="#你知道事件委托吗？能解释一下吗？" class="headerlink" title="你知道事件委托吗？能解释一下吗？"></a><strong>你知道事件委托吗？能解释一下吗？</strong></h4><p><strong>我：</strong> 是的，我知道事件委托 (Event Delegation)。</p>
<ul>
<li><strong>概念:</strong> 它是一种利用<strong>事件冒泡 (Event Bubbling)</strong> 机制，将事件监听器添加到<strong>父元素</strong>上，而不是直接添加到多个子元素上，用来管理一群子元素上发生的同类型事件的技术。</li>
<li><strong>原理:</strong> 当子元素上的事件被触发时，这个事件会沿着 DOM 树向上传播（冒泡）到其祖先元素。我们可以在父元素（或更上层的祖先元素）上设置一个监听器来捕获这个冒泡上来的事件。在父元素的监听函数内部，我们可以通过检查事件对象 <code>event</code> 的 <code>target</code> 属性 (<code>event.target</code>) 来判断事件<strong>实际起源于哪个子元素</strong>。如果这个 <code>target</code> 是我们关心的子元素类型，我们就可以执行相应的处理逻辑。</li>
<li>优点:<ol>
<li><strong>性能提升:</strong> 减少了需要添加到页面上的事件监听器的数量，从而减少了内存占用和 DOM 操作，尤其在子元素非常多的时候效果显著。</li>
<li><strong>动态元素支持:</strong> 对于后续通过 JavaScript 动态添加到父元素中的子元素，无需再单独为它们绑定事件监听器，事件委托的机制会自动处理这些新元素的事件。</li>
<li><strong>代码简化:</strong> 可以将多个子元素的事件处理逻辑集中到父元素的监听器中，使代码更简洁、易于维护。</li>
</ol>
</li>
</ul>
<h4 id="你知道事件的传递流程吗？（冒泡和捕获）"><a href="#你知道事件的传递流程吗？（冒泡和捕获）" class="headerlink" title="你知道事件的传递流程吗？（冒泡和捕获）"></a><strong>你知道事件的传递流程吗？（冒泡和捕获）</strong></h4><p><strong>我：</strong> 是的，我知道 DOM 事件的传递流程，它包含三个阶段：</p>
<ol>
<li><strong>捕获阶段 (Capturing Phase):</strong><ul>
<li>事件从 <code>window</code> 对象开始，沿着 DOM 树<strong>向下传播</strong>，经过目标元素的各个祖先节点，一直到达事件的目标元素 (Target Element)。</li>
<li>在这个阶段，如果在路径上的任何节点注册了<strong>捕获类型</strong>的事件监听器 (<code>addEventListener</code> 的第三个参数 <code>useCapture</code> 设置为 <code>true</code>)，那么这些监听器会被依次触发。</li>
</ul>
</li>
<li><strong>目标阶段 (Target Phase):</strong><ul>
<li>事件到达<strong>目标元素</strong>。</li>
<li>浏览器会触发注册在目标元素自身上的事件监听器。在这个阶段触发的监听器，无论是捕获还是冒泡类型注册的，都会被执行（执行顺序取决于注册顺序等因素，但它们都在目标阶段被调用）。</li>
</ul>
</li>
<li><strong>冒泡阶段 (Bubbling Phase):</strong><ul>
<li>事件从<strong>目标元素</strong>开始，沿着 DOM 树<strong>向上传播</strong>，经过其各个祖先节点，最终回到 <code>window</code> 对象。</li>
<li>在这个阶段，如果在路径上的任何节点注册了<strong>冒泡类型</strong>的事件监听器 (<code>addEventListener</code> 的第三个参数 <code>useCapture</code> 设置为 <code>false</code> 或省略，这是默认行为)，那么这些监听器会被依次触发。</li>
<li><strong>注意:</strong> 不是所有事件都会冒泡，例如 <code>focus</code>, <code>blur</code>, <code>load</code>, <code>unload</code> 等事件默认不冒泡。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>控制流程:</strong><ul>
<li>我们可以使用 <code>event.stopPropagation()</code> 方法在任何阶段阻止事件继续传播（阻止后续的捕获或冒泡）。</li>
<li><code>event.stopImmediatePropagation()</code> 不仅阻止传播，还会阻止<strong>同一元素上</strong>绑定<strong>同一事件类型</strong>的<strong>其他监听器</strong>被执行。</li>
</ul>
</li>
<li><strong>事件委托</strong> 主要利用的就是<strong>冒泡阶段</strong>。</li>
</ul>
<h4 id="CDN是什么"><a href="#CDN是什么" class="headerlink" title="CDN是什么?"></a><strong>CDN是什么?</strong></h4><p><strong>我：</strong> CDN 是 <strong>Content Delivery Network</strong> (内容分发网络) 的缩写。</p>
<ul>
<li><strong>概念:</strong> 它是一个由<strong>地理上分散</strong>的服务器（称为<strong>边缘节点</strong>或 PoP - Point of Presence）组成的网络，这些服务器协同工作，旨在更快、更可靠地将静态或动态 Web 内容（如图片、CSS 文件、JavaScript 文件、视频、HTML 页面等）分发给终端用户。</li>
<li>工作原理:<ol>
<li>网站的原始文件存储在<strong>源服务器 (Origin Server)</strong> 上。</li>
<li>CDN 服务商将这些文件的副本<strong>缓存</strong>到其全球各地的<strong>边缘服务器</strong>上。</li>
<li>当用户尝试访问网站内容时，CDN 的智能路由系统（通常基于 DNS）会将用户的请求导向到离用户<strong>地理位置最近</strong>或<strong>网络延迟最低</strong>的那个<strong>边缘服务器</strong>。</li>
<li>该边缘服务器直接将缓存的内容响应给用户。如果边缘服务器没有缓存该内容或缓存已过期，它会先向源服务器请求最新的内容，缓存后再响应给用户。</li>
</ol>
</li>
<li>主要优点:<ol>
<li><strong>加速网站加载速度:</strong> 用户从更近的服务器获取内容，大大减少了网络延迟 (Latency)。</li>
<li><strong>提高网站可用性和冗余:</strong> 即使某个边缘服务器或源服务器出现故障，请求也可以被路由到其他健康的服务器，减少了单点故障的风险。</li>
<li><strong>降低源服务器负载和带宽成本:</strong> 大部分用户请求由 CDN 边缘服务器处理，减轻了源服务器的压力和带宽消耗。</li>
<li><strong>增强网站的全球可扩展性:</strong> 可以轻松应对全球范围内的用户访问和流量高峰。</li>
<li><strong>提升安全性:</strong> 许多 CDN 提供商还提供额外的安全服务，如 DDoS 攻击缓解、Web 应用防火墙 (WAF) 等。</li>
</ol>
</li>
</ul>

    </div>
  </article>


</section>
    <footer id="footer" role="contentinfo">
    <div>&copy; 2025 <a href="/">DayBreak</a>.
    Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Designed by <a href="http://rainylog.com" target="_blank">Rainy.</a>
	</div>
</footer><!-- end #footer -->

  </div>
  
<script src="/lib/fancybox/dist/jquery.fancybox.min.js"></script>


  
<script src="/js/helper.js"></script>

  
<script src="/js/_third-party/gitment.js"></script>

</body>
</html>